\I\X31:Allocate the main arrays\X
\U30.
\I\X42:Backtrack to the previous level\X
\U39.
\I\X38:Check consistency\X
\U30.
\I\X32:Copy all the temporary cells to the \PB{\\{mem}} and \PB{\\{cmem}}
arrays in proper format\X
\U30.
\I\X37:Copy all the temporary variable nodes to the \PB{\\{vmem}} array in
proper format\X
\U30.
\I\X16:Find \PB{$\\{cur\_tmp\_var}\MG\\{name}$} in the hash table at \PB{\|p}\X
\U11.
\I\X34:Fix up the \PB{\\{blink}} fields and compute the list sizes\X
\U32.
\I\X3, 7, 26:Global variables\X
\U2.
\I\X17:Handle a duplicate literal\X
\U11.
\I\X41:Inactivate all clauses of the chosen list\X
\U39.
\I\X8, 14:Initialize everything\X
\U2.
\I\X10:Input the clause in \PB{\\{buf}}\X
\U9.
\I\X9:Input the clauses\X
\U2.
\I\X33:Insert the cells for the literals of clause \PB{\|c}\X
\U32.
\I\X13:Install a new \PB{\&{chunk}}\X
\U11.
\I\X12:Install a new \PB{\&{vchunk}}\X
\U11.
\I\X19:Move \PB{\\{cur\_cell}} backward to the previous cell\X
\Us18\ET33.
\I\X20:Move \PB{\\{cur\_tmp\_var}} backward to the previous temporary variable\X
\U37.
\I\X45:Print the solution found\X
\U39.
\I\X4:Process the command line\X
\U2.
\I\X15:Put the variable name beginning at \PB{\\{buf}[\|j]} in \PB{$\\{cur\_tmp%
\_var}\MG\\{name}$} and compute its hash code \PB{\|h}\X
\U11.
\I\X44:Put variable \PB{\\{level}} back into all clauses on the non-chosen list%
\X
\U42.
\I\X43:Reactivate all clauses of the chosen list\X
\U42.
\I\X18:Remove all variables of the current clause\X
\U10.
\I\X40:Remove variable \PB{\\{level}} from the clauses in the non-chosen list; %
\PB{\&{goto} \\{try\_again}} if that would make a clause empty\X
\U39.
\I\X21:Report the successful completion of the input phase\X
\U2.
\I\X11:Scan and record a variable; negate it if \PB{$\|i\E\T{1}$}\X
\U10.
\I\X30:Set up the main data structures\X
\U2.
\I\X39:Solve the problem\X
\U2.
\I\X35:Sort the literals within each clause\X
\U32.
\I\X27, 28, 29:Subroutines\X
\U2.
\I\X36:Swap cell \PB{\|j} with cell \PB{\|p}\X
\U35.
\I\X5, 6, 23, 24, 25:Type definitions\X
\U2.
