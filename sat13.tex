\input cwebmac
\datethis
\let\Xmod=\bmod % this is CWEB magic for using "mod" instead of "%"


\N{1}{1}Intro. This program is part of a family of ``SAT-solvers'' that I'm
putting
together for my own education as I prepare to write Section 7.2.2.2 of
{\sl The Art of Computer Programming}. My intent is to have a variety of
compatible programs on which I can run experiments to learn how different
approaches work in practice.

I'm hoping that this one, which has the lucky number {\mc SAT13},
will be the fastest of all, on a majority of the
example satisfiability problems that I've been exploring.
Why? Because it is based on the ``modern'' ideas of so-called
{\it conflict driven clause learning\/} (CDCL) solvers. This approach,
pioneered notably by Sakallah and Marques-Silva ({\mc GRASP}) and
by Moskewicz, Madigan, Zhao, Zhang, Malik ({\mc CHAFF}), has reportedly
revolutionized the field, making {\mc SAT}-solvers applicable to large-scale
industrial problems.

My model for {\mc SAT13} has been E\'en and S\"orensson's MiniSAT solver,
together with the Biere's PicoSAT solver, both of which were at one
time representative of world-class CDCL implementations. The technology has
continued to improve, and to become more complex than appropriate for
my book to survey; therefore I have not added all the latest bells and
whistles.
But I think this program decently represents the main CDCL paradigms.

If you have already read {\mc SAT10} (or some other program of this
series), you might as well skip now past all the code for the
``I/O wrapper,'' because you have seen it before.

The input on \PB{\\{stdin}} is a series of lines with one clause per line. Each
clause is a sequence of literals separated by spaces. Each literal is
a sequence of one to eight ASCII characters between \.{!} and \.{\}},
inclusive, not beginning with \.{\~},
optionally preceded by \.{\~} (which makes the literal ``negative'').
For example, Rivest's famous clauses on four variables,
found in 6.5--(13) and 7.1.1--(32) of {\sl TAOCP}, can be represented by the
following eight lines of input:
$$\chardef~=`\~
\vcenter{\halign{\tt#\cr
x2 x3 ~x4\cr
x1 x3 x4\cr
~x1 x2 x4\cr
~x1 ~x2 x3\cr
~x2 ~x3 x4\cr
~x1 ~x3 ~x4\cr
x1 ~x2 ~x4\cr
x1 x2 ~x3\cr}}$$
Input lines that begin with \.{\~\ } are ignored (treated as comments).
The output will be `\.{\~}' if the input clauses are unsatisfiable.
Otherwise it will be a list of noncontradictory literals that cover each
clause, separated by spaces. (``Noncontradictory'' means that we don't
have both a literal and its negation.) The input above would, for example,
yield `\.{\~}'; but if the final clause were omitted, the output would
be `\.{\~x1} \.{\~x2} \.{x3}', in some order, possibly together
with either \.{x4} or \.{\~x4} (but not both). No attempt is made to
find all solutions; at most one solution is given.

The running time in ``mems'' is also reported, together with the approximate
number of bytes needed for data storage. One ``mem'' essentially means a
memory access to a 64-bit word.
(These totals don't include the time or space needed to parse the
input or to format the output.)

\fi

\M{2}So here's the structure of the program. (Skip ahead if you are
impatient to see the interesting stuff.)

\Y\B\4\D$\|o$ \5
$\\{mems}\PP{}$\C{ count one mem }\par
\B\4\D$\\{oo}$ \5
$\\{mems}\MRL{+{\K}}{}$\T{2}\C{ count two mems }\par
\B\4\D$\\{ooo}$ \5
$\\{mems}\MRL{+{\K}}{}$\T{3}\C{ count three mems }\par
\B\4\D$\|O$ \5
\.{"\%"}\C{ used for percent signs in format strings }\par
\B\4\D$\Xmod$ \5
$\MOD{}$\C{ used for percent signs denoting remainder in \CEE/ }\Y\par
\B\4\D$\\{show\_basics}$ \5
\T{1}\C{ \PB{\\{verbose}} code for basic stats }\par
\B\4\D$\\{show\_choices}$ \5
\T{2}\C{ \PB{\\{verbose}} code for backtrack logging }\par
\B\4\D$\\{show\_details}$ \5
\T{4}\C{ \PB{\\{verbose}} code for further commentary }\par
\B\4\D$\\{show\_gory\_details}$ \5
\T{8}\C{ \PB{\\{verbose}} code for more yet }\par
\B\4\D$\\{show\_warmlearn}$ \5
\T{16}\C{ \PB{\\{verbose}} code for info about clauses learned during warmups }%
\par
\B\4\D$\\{show\_recycling}$ \5
\T{32}\C{ \PB{\\{verbose}} code to mention when recycling occurs }\par
\B\4\D$\\{show\_recycling\_details}$ \5
\T{64}\C{ \PB{\\{verbose}} code to display clauses that survive recycling }\par
\B\4\D$\\{show\_restarts}$ \5
\T{128}\C{ \PB{\\{verbose}} code to mention when restarts occur }\par
\B\4\D$\\{show\_initial\_clauses}$ \5
\T{256}\C{ \PB{\\{verbose}} code to list the unsatisfied clauses }\par
\B\4\D$\\{show\_watches}$ \5
\T{512}\C{ \PB{\\{verbose}} code to show when a watch list changes }\par
\B\4\D$\\{show\_experiments}$ \5
\T{4096}\C{ \PB{\\{verbose}} code sometimes used in change files }\par
\Y\B\8\#\&{include} \.{<stdio.h>}\6
\8\#\&{include} \.{<stdlib.h>}\6
\8\#\&{include} \.{<string.h>}\6
\8\#\&{include} \.{"gb\_flip.h"}\6
\&{typedef} \&{unsigned} \&{int} \&{uint};\C{ a convenient abbreviation }\6
\&{typedef} \&{unsigned} \&{long} \&{long} \&{ullng};\C{ ditto }\7
\X9:Type definitions\X;\6
\X4:Global variables\X;\6
\X139:Debugging fallbacks\X;\6
\X31:Subroutines\X;\7
\\{main}(\&{int} \\{argc}${},\39{}$\&{char} ${}{*}\\{argv}[\,]){}$\1\1\2\2\6
${}\{{}$\1\6
\&{register} \&{int} \|h${},{}$ \\{hp}${},{}$ \|i${},{}$ \|j${},{}$ %
\\{jj}${},{}$ \|k${},{}$ \\{kk}${},{}$ \|l${},{}$ \\{ll}${},{}$ \\{lll}${},{}$ %
\|p${},{}$ \|q${},{}$ \|r${},{}$ \|s;\6
\&{register} \&{int} \|c${},{}$ \\{cc}${},{}$ \\{endc}${},{}$ \\{la}${},{}$ %
\|t${},{}$ \|u${},{}$ \|v${},{}$ \|w${},{}$ \|x${},{}$ \|y;\6
\&{register} \&{double} \\{au}${},{}$ \\{av};\7
\X3:Process the command line\X;\6
\X12:Initialize everything\X;\6
\X13:Input the clauses\X;\6
\&{if} ${}(\\{verbose}\AND\\{show\_basics}){}$\1\5
\X25:Report the successful completion of the input phase\X;\2\6
\X45:Set up the main data structures\X;\6
${}\\{imems}\K\\{mems},\39\\{mems}\K\T{0};{}$\6
\X124:Solve the problem\X;\6
\4\\{all\_done}:\5
\X8:Close the files\X;\6
\X7:Print farewell messages\X;\6
\4${}\}{}$\2\par
\fi

\M{3}On the command line one can specify any or all of the following options:
\smallskip
\item{$\bullet$}
`\.v$\langle\,$integer$\,\rangle$' to enable various levels of verbose
output on \PB{\\{stderr}}.
\item{$\bullet$}
`\.c$\langle\,$positive integer$\,\rangle$' to limit the levels on which
choices are shown by \PB{\\{show\_choices}}.
\item{$\bullet$}
`\.H$\langle\,$positive integer$\,\rangle$' to limit the literals whose
histories are shown by \PB{\\{print\_state}}.
\item{$\bullet$}
`\.h$\langle\,$positive integer$\,\rangle$' to adjust the hash table size.
\item{$\bullet$}
`\.b$\langle\,$positive integer$\,\rangle$' to adjust the size of the input
buffer.
\item{$\bullet$}
`\.s$\langle\,$integer$\,\rangle$' to define the seed for any random numbers
that are used.
\item{$\bullet$}
`\.d$\langle\,$integer$\,\rangle$' to set \PB{\\{delta}} for periodic state
reports.
(See \PB{\\{print\_state}}.)
\item{$\bullet$}
`\.D$\langle\,$positive integer$\,\rangle$' to set \PB{\\{doomsday}}, the
number of conflicts after which this world comes to an end.
\item{$\bullet$}
`\.m$\langle\,$positive integer$\,\rangle$' to adjust the maximum memory size.
(The binary logarithm is specified; it must be at most 31.)
\item{$\bullet$}
`\.t$\langle\,$positive integer$\,\rangle$' to adjust \PB{\\{trivial\_limit}}
(default
10). A trivial clause is substituted for a learned clause when the size of the
latter is at least \PB{\\{trivial\_limit}} more than the size of the former.
\item{$\bullet$}
`\.w$\langle\,$integer$\,\rangle$' to set \PB{\\{warmups}}, the number of
``full runs''
done after a restart (default 0).
\item{$\bullet$}
`\.f$\langle\,$positive float$\,\rangle$' to adjust \PB{\\{restart\_psi%
\_fraction}}, the
minimum agility threshold between automatically scheduled restarts
(default 0.05).
\item{$\bullet$}
`\.j$\langle\,$integer$\,\rangle$' to adjust \PB{\\{recycle\_bump}}, the number
of
conflicts before the first recycling pass (default 1000).
\item{$\bullet$}
`\.J$\langle\,$positive integer$\,\rangle$' to adjust \PB{\\{recycle\_inc}},
the
increase in number of conflicts between recycling passes (default 500).
\item{$\bullet$}
`\.a$\langle\,$float$\,\rangle$' to adjust \PB{\\{alpha}}, the weight given to
unsatisfied levels when computing a clause's score during the recycling
process (default 0.4). This parameter must be between 0 and 1.
\item{$\bullet$}
`\.r$\langle\,$positive float$\,\rangle$' to adjust \PB{\\{var\_rho}}, the
damping factor for variable activity scores.
\item{$\bullet$}
`\.R$\langle\,$positive float$\,\rangle$' to adjust \PB{\\{clause\_rho}}, the
damping factor for clause activity scores.
\item{$\bullet$}
`\.p$\langle\,$nonnegative float$\,\rangle$' to adjust \PB{\\{rand\_prob}}, the
probability that a branch variable is chosen randomly.
\item{$\bullet$}
`\.P$\langle\,$nonnegative float$\,\rangle$' to adjust \PB{\\{true\_prob}}, the
probability that a variable's default initial value is true.
\item{$\bullet$}
`\.x$\langle\,$filename$\,\rangle$' to output a
solution-eliminating clause to the specified file. If the given problem is
satisfiable in more than one way, a different solution can be obtained by
appending that file to the input.
\item{$\bullet$}
`\.l$\langle\,$filename$\,\rangle$' to output all of the learned clauses
of length $\le \PB{\\{learn\_save}}$
to the specified file. (This data can be used, for example, as a certificate
of unsatisfiability.)
\item{$\bullet$}
`\.K$\langle\,$positive integer$\,\rangle$' to adjust the \PB{\\{learn\_save}}
parameter (default 10000).
\item{$\bullet$}
`\.L$\langle\,$filename$\,\rangle$' to output some learned clauses
to the specified file, for purposes of restarting after doomsday. (Those
clauses can be combined with the original clauses and simplified by
a preprocessor.)
\item{$\bullet$}
`\.z$\langle\,$filename$\,\rangle$' to input a ``polarity file,'' which is
a list of literals that receive specified default values to be used
until forced otherwise. (Literals in this file whose names do not appear
within any of the input clauses are ignored.)
\item{$\bullet$}
`\.Z$\langle\,$filename$\,\rangle$' to output a ``polarity file'' that will
be suitable for restarting after doomsday.
\item{$\bullet$}
`\.T$\langle\,$integer$\,\rangle$' to set \PB{\\{timeout}}: This program will
abruptly terminate, when it discovers that \PB{$\\{mems}>\\{timeout}$}.

\Y\B\4\X3:Process the command line\X${}\E{}$\6
\&{for} ${}(\|j\K\\{argc}-\T{1},\39\|k\K\T{0};{}$ \|j; ${}\|j\MM){}$\1\6
\&{switch} (\\{argv}[\|j][\T{0}])\5
${}\{{}$\1\6
\X5:Respond to a command-line option, setting \PB{\|k} nonzero on error\X;\6
\4\&{default}:\5
${}\|k\K\T{1}{}$;\C{ unrecognized command-line option }\6
\4${}\}{}$\2\2\6
\X6:If there's a problem, print a message about \.{Usage:} and \PB{\\{exit}}\X;%
\par
\U2.\fi

\M{4}\B\X4:Global variables\X${}\E{}$\6
\&{int} \\{random\_seed}${}\K\T{0}{}$;\C{ seed for the random words of \PB{%
\\{gb\_rand}} }\6
\&{int} \\{verbose}${}\K\\{show\_basics}{}$;\C{ level of verbosity }\6
\&{uint} \\{show\_choices\_max}${}\K\T{1000000}{}$;\C{ above this level, \PB{%
\\{show\_choices}} is ignored }\6
\&{int} \\{hbits}${}\K\T{8}{}$;\C{ logarithm of the number of the hash lists }\6
\&{int} \\{print\_state\_cutoff}${}\K\T{0}{}$;\C{ don't print more than this
many hists }\6
\&{int} \\{buf\_size}${}\K\T{1024}{}$;\C{ must exceed the length of the longest
input line }\6
\&{FILE} ${}{*}\\{out\_file}{}$;\C{ file for optional output of a
solution-avoiding clause }\6
\&{char} ${}{*}\\{out\_name}{}$;\C{ its name }\6
\&{FILE} ${}{*}\\{restart\_file}{}$;\C{ file for learned clauses to be used in
a restart }\6
\&{char} ${}{*}\\{restart\_name}{}$;\C{ its name }\6
\&{FILE} ${}{*}\\{learned\_file}{}$;\C{ file for output of every learned clause
}\6
\&{char} ${}{*}\\{learned\_name}{}$;\C{ its name }\6
\&{int} \\{learn\_save}${}\K\T{10000}{}$;\C{ theshold for not outputting to %
\PB{\\{learned\_file}} }\6
\&{ullng} \\{learned\_out};\C{ this many learned clauses have been output }\6
\&{FILE} ${}{*}\\{polarity\_infile}{}$;\C{ file for input of literal polarities
}\6
\&{char} ${}{*}\\{polarity\_in\_name}{}$;\C{ its name }\6
\&{FILE} ${}{*}\\{polarity\_outfile}{}$;\C{ file for output of literal
polarities }\6
\&{char} ${}{*}\\{polarity\_out\_name}{}$;\C{ its name }\6
\&{ullng} \\{imems}${},{}$ \\{mems};\C{ mem counts }\6
\&{ullng} \\{bytes};\C{ memory used by main data structures }\6
\&{ullng} \\{nodes};\C{ the number of nodes entered }\6
\&{ullng} \\{thresh}${}\K\T{0}{}$;\C{ report when \PB{\\{mems}} exceeds this,
if \PB{$\\{delta}\I\T{0}$} }\6
\&{ullng} \\{delta}${}\K\T{0}{}$;\C{ report every \PB{\\{delta}} or so mems }\6
\&{ullng} \\{timeout}${}\K\T{\^1fffffffffffffff}{}$;\C{ give up after this many
mems }\6
\&{uint} \\{memk\_max}${}\K\\{memk\_max\_default}{}$;\C{ binary log of the
maximum size of \PB{\\{mem}} }\6
\&{uint} \\{max\_cells\_used};\C{ how much of \PB{\\{mem}} has ever held data?
}\6
\&{int} \\{trivial\_limit}${}\K\T{10}{}$;\C{ threshold for substituting trivial
clauses }\6
\&{float} \\{var\_rho}${}\K\T{0.9}{}$;\C{ damping factor for variable activity
}\6
\&{float} \\{clause\_rho}${}\K\T{0.9995}{}$;\C{ damping factor for clause
activity }\6
\&{float} \\{rand\_prob}${}\K\T{0.02}{}$;\C{ probability of choosing at random
}\6
\&{float} \\{true\_prob}${}\K\T{0.50}{}$;\C{ probability of starting true on
first ascent }\6
\&{uint} \\{rand\_prob\_thresh};\C{ $2^{31}$ times \PB{\\{rand\_prob}} }\6
\&{uint} \\{true\_prob\_thresh};\C{ $2^{31}$ times \PB{\\{true\_prob}} }\6
\&{float} \\{alpha}${}\K\T{0.4}{}$;\C{ weighting for unsatisfiable levels in
clause scores }\6
\&{int} \\{warmups}${}\K\T{0}{}$;\C{ the number of full runs done after restart
}\6
\&{ullng} \\{total\_learned};\C{ we've learned this many clauses }\6
\&{double} \\{cells\_learned};\C{ and this is their total length }\6
\&{double} \\{cells\_prelearned};\C{ which was this before simplification }\6
\&{ullng} \\{discards};\C{ we quickly discarded this many of those clauses }\6
\&{ullng} \\{trivials};\C{ we learned this many intentionally trivial clauses }%
\6
\&{ullng} \\{subsumptions};\C{ we subsumed this many clauses on-the-fly }\6
\&{ullng} \\{doomsday}${}\K\T{\^8000000000000000}{}$;\C{ force endgame when %
\PB{\\{total\_learned}} exceeds this }\6
\&{ullng} \\{next\_recycle};\C{ begin recycling when \PB{\\{total\_learned}}
exceeds this }\6
\&{ullng} \\{recycle\_bump}${}\K\T{1000}{}$;\C{ interval till the next
recycling time }\6
\&{ullng} \\{recycle\_inc}${}\K\T{500}{}$;\C{ amount to increase \PB{\\{recycle%
\_bump}} after each round }\6
\&{ullng} \\{next\_restart};\C{ begin to restart when \PB{\\{total\_learned}}
exceeds this }\6
\&{ullng} \\{restart\_psi};\C{ minimum agility threshold for restarts }\6
\&{float} \\{restart\_psi\_fraction}${}\K\T{.05}{}$;\C{ fractional equivalent
of \PB{\\{restart\_psi}} }\6
\&{ullng} \\{actual\_restarts};\par
\As11, 27, 41, 59, 80, 90, 97, 111\ETs140.
\U2.\fi

\M{5}\B\X5:Respond to a command-line option, setting \PB{\|k} nonzero on error%
\X${}\E{}$\6
\4\&{case} \.{'v'}:\5
${}\|k\MRL{{\OR}{\K}}(\\{sscanf}(\\{argv}[\|j]+\T{1},\39\.{""}\|O\.{"d"},\39{%
\AND}\\{verbose})-\T{1}){}$;\5
\&{break};\6
\4\&{case} \.{'c'}:\5
${}\|k\MRL{{\OR}{\K}}(\\{sscanf}(\\{argv}[\|j]+\T{1},\39\.{""}\|O\.{"d"},\39{%
\AND}\\{show\_choices\_max})-\T{1}){}$;\5
\&{break};\6
\4\&{case} \.{'H'}:\5
${}\|k\MRL{{\OR}{\K}}(\\{sscanf}(\\{argv}[\|j]+\T{1},\39\.{""}\|O\.{"d"},\39{%
\AND}\\{print\_state\_cutoff})-\T{1}){}$;\5
\&{break};\6
\4\&{case} \.{'h'}:\5
${}\|k\MRL{{\OR}{\K}}(\\{sscanf}(\\{argv}[\|j]+\T{1},\39\.{""}\|O\.{"d"},\39{%
\AND}\\{hbits})-\T{1}){}$;\5
\&{break};\6
\4\&{case} \.{'b'}:\5
${}\|k\MRL{{\OR}{\K}}(\\{sscanf}(\\{argv}[\|j]+\T{1},\39\.{""}\|O\.{"d"},\39{%
\AND}\\{buf\_size})-\T{1}){}$;\5
\&{break};\6
\4\&{case} \.{'s'}:\5
${}\|k\MRL{{\OR}{\K}}(\\{sscanf}(\\{argv}[\|j]+\T{1},\39\.{""}\|O\.{"d"},\39{%
\AND}\\{random\_seed})-\T{1}){}$;\5
\&{break};\6
\4\&{case} \.{'d'}:\5
${}\|k\MRL{{\OR}{\K}}(\\{sscanf}(\\{argv}[\|j]+\T{1},\39\.{""}\|O\.{"lld"},\39{%
\AND}\\{delta})-\T{1}){}$;\5
${}\\{thresh}\K\\{delta}{}$;\5
\&{break};\6
\4\&{case} \.{'D'}:\5
${}\|k\MRL{{\OR}{\K}}(\\{sscanf}(\\{argv}[\|j]+\T{1},\39\.{""}\|O\.{"lld"},\39{%
\AND}\\{doomsday})-\T{1}){}$;\5
\&{break};\6
\4\&{case} \.{'m'}:\5
${}\|k\MRL{{\OR}{\K}}(\\{sscanf}(\\{argv}[\|j]+\T{1},\39\.{""}\|O\.{"d"},\39{%
\AND}\\{memk\_max})-\T{1}){}$;\5
\&{break};\6
\4\&{case} \.{'t'}:\5
${}\|k\MRL{{\OR}{\K}}(\\{sscanf}(\\{argv}[\|j]+\T{1},\39\.{""}\|O\.{"d"},\39{%
\AND}\\{trivial\_limit})-\T{1}){}$;\5
\&{break};\6
\4\&{case} \.{'w'}:\5
${}\|k\MRL{{\OR}{\K}}(\\{sscanf}(\\{argv}[\|j]+\T{1},\39\.{""}\|O\.{"d"},\39{%
\AND}\\{warmups})-\T{1}){}$;\5
\&{break};\6
\4\&{case} \.{'j'}:\5
${}\|k\MRL{{\OR}{\K}}(\\{sscanf}(\\{argv}[\|j]+\T{1},\39\.{""}\|O\.{"lld"},\39{%
\AND}\\{recycle\_bump})-\T{1}){}$;\5
\&{break};\6
\4\&{case} \.{'J'}:\5
${}\|k\MRL{{\OR}{\K}}(\\{sscanf}(\\{argv}[\|j]+\T{1},\39\.{""}\|O\.{"lld"},\39{%
\AND}\\{recycle\_inc})-\T{1}){}$;\5
\&{break};\6
\4\&{case} \.{'K'}:\5
${}\|k\MRL{{\OR}{\K}}(\\{sscanf}(\\{argv}[\|j]+\T{1},\39\.{""}\|O\.{"d"},\39{%
\AND}\\{learn\_save})-\T{1}){}$;\5
\&{break};\6
\4\&{case} \.{'f'}:\5
${}\|k\MRL{{\OR}{\K}}(\\{sscanf}(\\{argv}[\|j]+\T{1},\39\.{""}\|O\.{"f"},\39{%
\AND}\\{restart\_psi\_fraction})-\T{1}){}$;\5
\&{break};\6
\4\&{case} \.{'a'}:\5
${}\|k\MRL{{\OR}{\K}}(\\{sscanf}(\\{argv}[\|j]+\T{1},\39\.{""}\|O\.{"f"},\39{%
\AND}\\{alpha})-\T{1}){}$;\5
\&{break};\6
\4\&{case} \.{'r'}:\5
${}\|k\MRL{{\OR}{\K}}(\\{sscanf}(\\{argv}[\|j]+\T{1},\39\.{""}\|O\.{"f"},\39{%
\AND}\\{var\_rho})-\T{1}){}$;\5
\&{break};\6
\4\&{case} \.{'R'}:\5
${}\|k\MRL{{\OR}{\K}}(\\{sscanf}(\\{argv}[\|j]+\T{1},\39\.{""}\|O\.{"f"},\39{%
\AND}\\{clause\_rho})-\T{1}){}$;\5
\&{break};\6
\4\&{case} \.{'p'}:\5
${}\|k\MRL{{\OR}{\K}}(\\{sscanf}(\\{argv}[\|j]+\T{1},\39\.{""}\|O\.{"f"},\39{%
\AND}\\{rand\_prob})-\T{1}){}$;\5
\&{break};\6
\4\&{case} \.{'P'}:\5
${}\|k\MRL{{\OR}{\K}}(\\{sscanf}(\\{argv}[\|j]+\T{1},\39\.{""}\|O\.{"f"},\39{%
\AND}\\{true\_prob})-\T{1}){}$;\5
\&{break};\6
\4\&{case} \.{'x'}:\5
${}\\{out\_name}\K\\{argv}[\|j]+\T{1},\39\\{out\_file}\K\\{fopen}(\\{out%
\_name},\39\.{"w"});{}$\6
\&{if} ${}(\R\\{out\_file}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"Sorry,\ I\ can't\ open}\)\.{\ file\ `"}\|O%
\.{"s'\ for\ writing!\\n"},\39\\{out\_name});{}$\2\6
\&{break};\6
\4\&{case} \.{'l'}:\5
${}\\{learned\_name}\K\\{argv}[\|j]+\T{1},\39\\{learned\_file}\K\\{fopen}(%
\\{learned\_name},\39\.{"w"});{}$\6
\&{if} ${}(\R\\{learned\_file}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"Sorry,\ I\ can't\ open}\)\.{\ file\ `"}\|O%
\.{"s'\ for\ writing!\\n"},\39\\{learned\_name});{}$\2\6
\&{break};\6
\4\&{case} \.{'L'}:\5
${}\\{restart\_name}\K\\{argv}[\|j]+\T{1},\39\\{restart\_file}\K\\{fopen}(%
\\{restart\_name},\39\.{"w"});{}$\6
\&{if} ${}(\R\\{restart\_file}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"Sorry,\ I\ can't\ open}\)\.{\ file\ `"}\|O%
\.{"s'\ for\ writing!\\n"},\39\\{restart\_name});{}$\2\6
\&{break};\6
\4\&{case} \.{'z'}:\5
${}\\{polarity\_in\_name}\K\\{argv}[\|j]+\T{1},\39\\{polarity\_infile}\K%
\\{fopen}(\\{polarity\_in\_name},\39\.{"r"});{}$\6
\&{if} ${}(\R\\{polarity\_infile}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"Sorry,\ I\ can't\ open}\)\.{\ file\ `"}\|O%
\.{"s'\ for\ reading!\\n"},\39\\{polarity\_in\_name});{}$\2\6
\&{break};\6
\4\&{case} \.{'Z'}:\5
${}\\{polarity\_out\_name}\K\\{argv}[\|j]+\T{1},\39\\{polarity\_outfile}\K%
\\{fopen}(\\{polarity\_out\_name},\39\.{"w"});{}$\6
\&{if} ${}(\R\\{polarity\_outfile}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"Sorry,\ I\ can't\ open}\)\.{\ file\ `"}\|O%
\.{"s'\ for\ writing!\\n"},\39\\{polarity\_out\_name});{}$\2\6
\&{break};\6
\4\&{case} \.{'T'}:\5
${}\|k\MRL{{\OR}{\K}}(\\{sscanf}(\\{argv}[\|j]+\T{1},\39\.{""}\|O\.{"lld"},\39{%
\AND}\\{timeout})-\T{1}){}$;\5
\&{break};\par
\U3.\fi

\M{6}\B\X6:If there's a problem, print a message about \.{Usage:} and \PB{%
\\{exit}}\X${}\E{}$\6
\&{if} ${}(\|k\V\\{hbits}<\T{0}\V\\{hbits}>\T{30}\V\\{buf\_size}\Z\T{0}\V%
\\{memk\_max}<\T{2}\V\\{memk\_max}>\T{31}\V\\{trivial\_limit}\Z\T{0}\V{}$(%
\&{int}) \\{recycle\_inc}${}<\T{0}\V\\{alpha}<\T{0.0}\V\\{alpha}>\T{1.0}\V%
\\{rand\_prob}<\T{0.0}\V\\{true\_prob}<\T{0.0}\V\\{var\_rho}\Z\T{0.0}\V%
\\{clause\_rho}\Z\T{0.0}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Usage:\ "}\|O\.{"s\ [v<n>]\ [c<n>]\ [H<}\)%
\.{n>]\ [h<n>]\ [b<n>]\ [s}\)\.{<n>]\ [d<n>]"},\39\\{argv}[\T{0}]);{}$\6
${}\\{fprintf}(\\{stderr},\39\.{"\ [D<n>]\ [m<n>]\ [t<n}\)\.{>]\ [w<n>]\ [j<n>]%
\ [J<}\)\.{n>]\ [K<n>]"});{}$\6
${}\\{fprintf}(\\{stderr},\39\.{"\ [f<f>]\ [a<f>]\ [r<f}\)\.{>]\ [R<f>]\ [p<f>]%
\ [P<}\)\.{f>]"});{}$\6
${}\\{fprintf}(\\{stderr},\39\.{"\ [x<foo>]\ [l<bar>]\ }\)\.{[L<baz>]\ [z<poi>]%
\ [Z}\)\.{<poo>]\ [T<n>]\ <\ foo.}\)\.{sat\\n"});{}$\6
${}\\{exit}({-}\T{1});{}$\6
\4${}\}{}$\2\par
\U3.\fi

\M{7}\B\X7:Print farewell messages\X${}\E{}$\6
\&{if} ${}(\\{verbose}\AND\\{show\_basics}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Altogether\ "}\|O\.{"llu+"}\|O\.{"llu\ mems,\
"}\|O\.{"llu\ bytes,\ "}\|O\.{"llu\ node"}\|O\.{"s,"},\39\\{imems},\39\\{mems},%
\39\\{bytes},\39\\{nodes},\39\\{nodes}\E\T{1}\?\.{""}:\.{"s"});{}$\6
${}\\{fprintf}(\\{stderr},\39\.{"\ "}\|O\.{"llu\ clauses\ learned}\)\.{"},\39%
\\{total\_learned});{}$\6
\&{if} (\\{total\_learned})\1\5
${}\\{fprintf}(\\{stderr},\39\.{"\ (ave\ "}\|O\.{".1f->"}\|O\.{".1f)"},\39%
\\{cells\_prelearned}/{}$(\&{double}) \\{total\_learned}${},\39\\{cells%
\_learned}/{}$(\&{double}) \\{total\_learned});\2\6
${}\\{fprintf}(\\{stderr},\39\.{",\ "}\|O\.{"u\ memcells.\\n"},\39\\{max\_cells%
\_used});{}$\6
\&{if} (\\{learned\_file})\1\5
${}\\{fprintf}(\\{stderr},\39\.{""}\|O\.{"lld\ learned\ clauses}\)\.{\ written\
to\ file\ `"}\|O\.{"s'.\\n"},\39\\{learned\_out},\39\\{learned\_name});{}$\2\6
\&{if} (\\{trivials})\1\5
${}\\{fprintf}(\\{stderr},\39\.{"("}\|O\.{"lld\ learned\ clause"}\|O\.{"s\
trivial.)\\n"},\39\\{trivials},\39\\{trivials}\E\T{1}\?\.{"\ was"}:\.{"s\
were"});{}$\2\6
\&{if} (\\{discards})\1\5
${}\\{fprintf}(\\{stderr},\39\.{"("}\|O\.{"lld\ learned\ clause"}\|O\.{"s\
discarded.)\\n"},\39\\{discards},\39\\{discards}\E\T{1}\?\.{"\ was"}:\.{"s\
were"});{}$\2\6
\&{if} (\\{subsumptions})\1\5
${}\\{fprintf}(\\{stderr},\39\.{"("}\|O\.{"lld\ clause"}\|O\.{"s\ subsumed\
on-the-f}\)\.{ly.)\\n"},\39\\{subsumptions},\39\\{subsumptions}\E\T{1}\?\.{"\
was"}:\.{"s\ were"});{}$\2\6
${}\\{fprintf}(\\{stderr},\39\.{"("}\|O\.{"lld\ restart"}\|O\.{"s.)\\n"},\39%
\\{actual\_restarts},\39\\{actual\_restarts}\E\T{1}\?\.{""}:\.{"s"});{}$\6
\4${}\}{}$\2\par
\U2.\fi

\M{8}\B\X8:Close the files\X${}\E{}$\6
\&{if} (\\{out\_file})\1\5
\\{fclose}(\\{out\_file});\2\6
\&{if} (\\{learned\_file})\1\5
\\{fclose}(\\{learned\_file});\2\6
\&{if} (\\{restart\_file})\1\5
\\{fclose}(\\{restart\_file});\2\6
\&{if} (\\{polarity\_infile})\1\5
\\{fclose}(\\{polarity\_infile});\2\6
\&{if} (\\{polarity\_outfile})\1\5
\\{fclose}(\\{polarity\_outfile});\2\par
\U2.\fi

\N{1}{9}The I/O wrapper. The following routines read the input and absorb it
into
temporary data areas from which all of the ``real'' data structures
can readily be initialized. My intent is to incorporate these routines into all
of the SAT-solvers in this series. Therefore I've tried to make the code
short and simple, yet versatile enough so that almost no restrictions are
placed on the sizes of problems that can be handled. These routines are
supposed to work properly unless there are more than
$2^{32}-1=4$,294,967,295 occurrences of literals in clauses,
or more than $2^{31}-1=2$,147,483,647 variables or clauses.

In these temporary tables, each variable is represented by four things:
its unique name; its serial number; the clause number (if any) in which it has
most recently appeared; and a pointer to the previous variable (if any)
with the same hash address. Several variables at a time
are represented sequentially in small chunks of memory called ``vchunks,''
which are allocated as needed (and freed later).

\Y\B\4\D$\\{vars\_per\_vchunk}$ \5
\T{341}\C{ preferably $(2^k-1)/3$ for some $k$ }\par
\Y\B\4\X9:Type definitions\X${}\E{}$\6
\&{typedef} \&{union} ${}\{{}$\1\6
\&{char} \\{ch8}[\T{8}];\6
\&{uint} \\{u2}[\T{2}];\6
\&{ullng} \\{lng};\2\6
${}\}{}$ \&{octa};\6
\&{typedef} \&{struct} \&{tmp\_var\_struct} ${}\{{}$\1\6
\&{octa} \\{name};\C{ the name (one to eight ASCII characters) }\6
\&{uint} \\{serial};\C{ 0 for the first variable, 1 for the second, etc. }\6
\&{int} \\{stamp};\C{ \PB{\|m} if positively in clause \PB{\|m}; \PB{${-}\|m$}
if negatively there }\6
\&{struct} \&{tmp\_var\_struct} ${}{*}\\{next}{}$;\C{ pointer for hash list }\2%
\6
${}\}{}$ \&{tmp\_var};\7
\&{typedef} \&{struct} \&{vchunk\_struct} ${}\{{}$\1\6
\&{struct} \&{vchunk\_struct} ${}{*}\\{prev}{}$;\C{ previous chunk allocated
(if any) }\6
\&{tmp\_var} \\{var}[\\{vars\_per\_vchunk}];\2\6
${}\}{}$ \&{vchunk};\par
\As10, 28, 29\ETs30.
\U2.\fi

\M{10}Each clause in the temporary tables is represented by a sequence of
one or more pointers to the \PB{\&{tmp\_var}} nodes of the literals involved.
A negated literal is indicated by adding~1 to such a pointer.
The first literal of a clause is indicated by adding~2.
Several of these pointers are represented sequentially in chunks
of memory, which are allocated as needed and freed later.

\Y\B\4\D$\\{cells\_per\_chunk}$ \5
\T{511}\C{ preferably $2^k-1$ for some $k$ }\par
\Y\B\4\X9:Type definitions\X${}\mathrel+\E{}$\6
\&{typedef} \&{struct} \&{chunk\_struct} ${}\{{}$\1\6
\&{struct} \&{chunk\_struct} ${}{*}\\{prev}{}$;\C{ previous chunk allocated (if
any) }\6
\&{tmp\_var} ${}{*}\\{cell}[\\{cells\_per\_chunk}];{}$\2\6
${}\}{}$ \&{chunk};\par
\fi

\M{11}\B\X4:Global variables\X${}\mathrel+\E{}$\6
\&{char} ${}{*}\\{buf}{}$;\C{ buffer for reading the lines (clauses) of \PB{%
\\{stdin}} }\6
\&{tmp\_var} ${}{*}{*}\\{hash}{}$;\C{ heads of the hash lists }\6
\&{uint} \\{hash\_bits}[\T{93}][\T{8}];\C{ random bits for universal hash
function }\6
\&{vchunk} ${}{*}\\{cur\_vchunk}{}$;\C{ the vchunk currently being filled }\6
\&{tmp\_var} ${}{*}\\{cur\_tmp\_var}{}$;\C{ current place to create new \PB{%
\&{tmp\_var}} entries }\6
\&{tmp\_var} ${}{*}\\{bad\_tmp\_var}{}$;\C{ the \PB{\\{cur\_tmp\_var}} when we
need a new \PB{\&{vchunk}} }\6
\&{chunk} ${}{*}\\{cur\_chunk}{}$;\C{ the chunk currently being filled }\6
\&{tmp\_var} ${}{*}{*}\\{cur\_cell}{}$;\C{ current place to create new elements
of a clause }\6
\&{tmp\_var} ${}{*}{*}\\{bad\_cell}{}$;\C{ the \PB{\\{cur\_cell}} when we need
a new \PB{\&{chunk}} }\6
\&{ullng} \\{vars};\C{ how many distinct variables have we seen? }\6
\&{ullng} \\{clauses};\C{ how many clauses have we seen? }\6
\&{ullng} \\{nullclauses};\C{ how many of them were null? }\6
\&{int} \\{unaries};\C{ how many were unary? }\6
\&{int} \\{binaries};\C{ how many were binary? }\6
\&{ullng} \\{cells};\C{ how many occurrences of literals in clauses? }\par
\fi

\M{12}\B\X12:Initialize everything\X${}\E{}$\6
\\{gb\_init\_rand}(\\{random\_seed});\6
${}\\{buf}\K{}$(\&{char} ${}{*}){}$ \\{malloc}${}(\\{buf\_size}*\&{sizeof}(%
\&{char}));{}$\6
\&{if} ${}(\R\\{buf}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Couldn't\ allocate\ t}\)\.{he\ input\ buffer\
(buf}\)\.{\_size="}\|O\.{"d)!\\n"},\39\\{buf\_size});{}$\6
${}\\{exit}({-}\T{2});{}$\6
\4${}\}{}$\2\6
${}\\{hash}\K{}$(\&{tmp\_var} ${}{*}{*}){}$ \\{malloc}${}(\&{sizeof}(\&{tmp%
\_var})\LL\\{hbits});{}$\6
\&{if} ${}(\R\\{hash}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Couldn't\ allocate\ "}\|O\.{"d\ hash\ list\
heads\ (}\)\.{hbits="}\|O\.{"d)!\\n"},\39\T{1}\LL\\{hbits},\39\\{hbits});{}$\6
${}\\{exit}({-}\T{3});{}$\6
\4${}\}{}$\2\6
\&{for} ${}(\|h\K\T{0};{}$ ${}\|h<\T{1}\LL\\{hbits};{}$ ${}\|h\PP){}$\1\5
${}\\{hash}[\|h]\K\NULL{}$;\2\par
\A18.
\U2.\fi

\M{13}The hash address of each variable name has $h$ bits, where $h$ is the
value of the adjustable parameter \PB{\\{hbits}}.
Thus the average number of variables per hash list is $n/2^h$ when there
are $n$ different variables. A warning is printed if this average number
exceeds 10. (For example, if $h$ has its default value, 8, the program will
suggest that you might want to increase $h$ if your input has 2560
different variables or more.)

All the hashing takes place at the very beginning,
and the hash tables are actually recycled before any SAT-solving takes place;
therefore the setting of this parameter is by no means crucial. But I didn't
want to bother with fancy coding that would determine $h$ automatically.

\Y\B\4\X13:Input the clauses\X${}\E{}$\6
\&{while} (\T{1})\5
${}\{{}$\1\6
\&{if} ${}(\R\\{fgets}(\\{buf},\39\\{buf\_size},\39\\{stdin})){}$\1\5
\&{break};\2\6
${}\\{clauses}\PP;{}$\6
\&{if} ${}(\\{buf}[\\{strlen}(\\{buf})-\T{1}]\I\.{'\\n'}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"The\ clause\ on\ line\ }\)\.{"}\|O\.{"lld\ ("}%
\|O\.{".20s...)\ is\ too\ lon}\)\.{g\ for\ me;\\n"},\39\\{clauses},\39%
\\{buf});{}$\6
${}\\{fprintf}(\\{stderr},\39\.{"\ my\ buf\_size\ is\ onl}\)\.{y\ "}\|O\.{"d!%
\\n"},\39\\{buf\_size});{}$\6
${}\\{fprintf}(\\{stderr},\39\.{"Please\ use\ the\ comm}\)\.{and-line\ option\
b<ne}\)\.{wsize>.\\n"});{}$\6
${}\\{exit}({-}\T{4});{}$\6
\4${}\}{}$\2\6
\X14:Input the clause in \PB{\\{buf}}\X;\6
\4${}\}{}$\2\6
\&{if} ${}((\\{vars}\GG\\{hbits})\G\T{10}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"There\ are\ "}\|O\.{"lld\ variables\ but\ o}\)%
\.{nly\ "}\|O\.{"d\ hash\ tables;\\n"},\39\\{vars},\39\T{1}\LL\\{hbits});{}$\6
\&{for} ${}(\|h\K\\{hbits}+\T{1};{}$ ${}(\\{vars}\GG\|h)\G\T{10};{}$ ${}\|h%
\PP){}$\1\5
;\2\6
${}\\{fprintf}(\\{stderr},\39\.{"\ maybe\ you\ should\ u}\)\.{se\ command-line\
opti}\)\.{on\ h"}\|O\.{"d?\\n"},\39\|h);{}$\6
\4${}\}{}$\2\6
${}\\{clauses}\MRL{-{\K}}\\{nullclauses};{}$\6
\&{if} ${}(\\{clauses}\E\T{0}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"No\ clauses\ were\ inp}\)\.{ut!\\n"});{}$\6
${}\\{exit}({-}\T{77});{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{vars}\G\T{\^80000000}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Whoa,\ the\ input\ had}\)\.{\ "}\|O\.{"llu\
variables!\\n"},\39\\{cells});{}$\6
${}\\{exit}({-}\T{664});{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{clauses}\G\T{\^80000000}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Whoa,\ the\ input\ had}\)\.{\ "}\|O\.{"llu\
clauses!\\n"},\39\\{cells});{}$\6
${}\\{exit}({-}\T{665});{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{cells}\G\T{\^100000000}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Whoa,\ the\ input\ had}\)\.{\ "}\|O\.{"llu\
occurrences\ of\ }\)\.{literals!\\n"},\39\\{cells});{}$\6
${}\\{exit}({-}\T{666});{}$\6
\4${}\}{}$\2\par
\U2.\fi

\M{14}\B\X14:Input the clause in \PB{\\{buf}}\X${}\E{}$\6
\&{for} ${}(\|j\K\|k\K\T{0};{}$  ; \,)\5
${}\{{}$\1\6
\&{while} ${}(\\{buf}[\|j]\E\.{'\ '}){}$\1\5
${}\|j\PP{}$;\C{ scan to nonblank }\2\6
\&{if} ${}(\\{buf}[\|j]\E\.{'\\n'}){}$\1\5
\&{break};\2\6
\&{if} ${}(\\{buf}[\|j]<\.{'\ '}\V\\{buf}[\|j]>\.{'\~'}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Illegal\ character\ (}\)\.{code\ \#"}\|O\.{"x)%
\ in\ the\ clause\ on}\)\.{\ line\ "}\|O\.{"lld!\\n"},\39\\{buf}[\|j],\39%
\\{clauses});{}$\6
${}\\{exit}({-}\T{5});{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{buf}[\|j]\E\.{'\~'}){}$\1\5
${}\|i\K\T{1},\39\|j\PP;{}$\2\6
\&{else}\1\5
${}\|i\K\T{0};{}$\2\6
\X15:Scan and record a variable; negate it if \PB{$\|i\E\T{1}$}\X;\6
\4${}\}{}$\2\6
\&{if} ${}(\|k\E\T{0}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"(Empty\ line\ "}\|O\.{"lld\ is\ being\ ignore}%
\)\.{d)\\n"},\39\\{clauses});{}$\6
${}\\{nullclauses}\PP{}$;\C{ strictly speaking it would be unsatisfiable }\6
\4${}\}{}$\2\6
\&{goto} \\{clause\_done};\6
\4\\{empty\_clause}:\5
\X22:Remove all variables of the current clause\X;\6
\4\\{clause\_done}:\5
${}\\{cells}\MRL{+{\K}}\|k;{}$\6
\&{if} ${}(\|k\E\T{1}){}$\1\5
${}\\{unaries}\PP;{}$\2\6
\&{else} \&{if} ${}(\|k\E\T{2}){}$\1\5
${}\\{binaries}\PP{}$;\2\par
\U13.\fi

\M{15}We need a hack to insert the bit codes 1 and/or 2 into a pointer value.

\Y\B\4\D$\\{hack\_in}(\|q,\|t)$ \5
(\&{tmp\_var} ${}{*})(\|t\OR{}$(\&{ullng}) \|q)\par
\Y\B\4\X15:Scan and record a variable; negate it if \PB{$\|i\E\T{1}$}\X${}\E{}$%
\6
${}\{{}$\1\6
\&{register} \&{tmp\_var} ${}{*}\|p;{}$\7
\&{if} ${}(\\{cur\_tmp\_var}\E\\{bad\_tmp\_var}){}$\1\5
\X16:Install a new \PB{\&{vchunk}}\X;\2\6
\X19:Put the variable name beginning at \PB{\\{buf}[\|j]} in \PB{$\\{cur\_tmp%
\_var}\MG\\{name}$} and compute its hash code \PB{\|h}\X;\6
\X20:Find \PB{$\\{cur\_tmp\_var}\MG\\{name}$} in the hash table at \PB{\|p}\X;\6
\&{if} ${}(\|p\MG\\{stamp}\E\\{clauses}\V\|p\MG\\{stamp}\E{-}\\{clauses}){}$\1\5
\X21:Handle a duplicate literal\X\2\6
\&{else}\5
${}\{{}$\1\6
${}\|p\MG\\{stamp}\K(\|i\?{-}\\{clauses}:\\{clauses});{}$\6
\&{if} ${}(\\{cur\_cell}\E\\{bad\_cell}){}$\1\5
\X17:Install a new \PB{\&{chunk}}\X;\2\6
${}{*}\\{cur\_cell}\K\|p;{}$\6
\&{if} ${}(\|i\E\T{1}){}$\1\5
${}{*}\\{cur\_cell}\K\\{hack\_in}({*}\\{cur\_cell},\39\T{1});{}$\2\6
\&{if} ${}(\|k\E\T{0}){}$\1\5
${}{*}\\{cur\_cell}\K\\{hack\_in}({*}\\{cur\_cell},\39\T{2});{}$\2\6
${}\\{cur\_cell}\PP,\39\|k\PP;{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U14.\fi

\M{16}\B\X16:Install a new \PB{\&{vchunk}}\X${}\E{}$\6
${}\{{}$\1\6
\&{register} \&{vchunk} ${}{*}\\{new\_vchunk};{}$\7
${}\\{new\_vchunk}\K{}$(\&{vchunk} ${}{*}){}$ \\{malloc}(\&{sizeof}(%
\&{vchunk}));\6
\&{if} ${}(\R\\{new\_vchunk}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Can't\ allocate\ a\ ne}\)\.{w\ vchunk!%
\\n"});{}$\6
${}\\{exit}({-}\T{6});{}$\6
\4${}\}{}$\2\6
${}\\{new\_vchunk}\MG\\{prev}\K\\{cur\_vchunk},\39\\{cur\_vchunk}\K\\{new%
\_vchunk};{}$\6
${}\\{cur\_tmp\_var}\K{\AND}\\{new\_vchunk}\MG\\{var}[\T{0}];{}$\6
${}\\{bad\_tmp\_var}\K{\AND}\\{new\_vchunk}\MG\\{var}[\\{vars\_per%
\_vchunk}];{}$\6
\4${}\}{}$\2\par
\U15.\fi

\M{17}\B\X17:Install a new \PB{\&{chunk}}\X${}\E{}$\6
${}\{{}$\1\6
\&{register} \&{chunk} ${}{*}\\{new\_chunk};{}$\7
${}\\{new\_chunk}\K{}$(\&{chunk} ${}{*}){}$ \\{malloc}(\&{sizeof}(\&{chunk}));\6
\&{if} ${}(\R\\{new\_chunk}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Can't\ allocate\ a\ ne}\)\.{w\ chunk!%
\\n"});{}$\6
${}\\{exit}({-}\T{7});{}$\6
\4${}\}{}$\2\6
${}\\{new\_chunk}\MG\\{prev}\K\\{cur\_chunk},\39\\{cur\_chunk}\K\\{new%
\_chunk};{}$\6
${}\\{cur\_cell}\K{\AND}\\{new\_chunk}\MG\\{cell}[\T{0}];{}$\6
${}\\{bad\_cell}\K{\AND}\\{new\_chunk}\MG\\{cell}[\\{cells\_per\_chunk}];{}$\6
\4${}\}{}$\2\par
\U15.\fi

\M{18}The hash code is computed via ``universal hashing,'' using the following
precomputed tables of random bits.

\Y\B\4\X12:Initialize everything\X${}\mathrel+\E{}$\6
\&{for} ${}(\|j\K\T{92};{}$ \|j; ${}\|j\MM){}$\1\6
\&{for} ${}(\|k\K\T{0};{}$ ${}\|k<\T{8};{}$ ${}\|k\PP){}$\1\5
${}\\{hash\_bits}[\|j][\|k]\K\\{gb\_next\_rand}(\,){}$;\2\2\par
\fi

\M{19}\B\X19:Put the variable name beginning at \PB{\\{buf}[\|j]} in \PB{$%
\\{cur\_tmp\_var}\MG\\{name}$} and compute its hash code \PB{\|h}\X${}\E{}$\6
$\\{cur\_tmp\_var}\MG\\{name}.\\{lng}\K\T{0};{}$\6
\&{for} ${}(\|h\K\|l\K\T{0};{}$ ${}\\{buf}[\|j+\|l]>\.{'\ '}\W\\{buf}[\|j+\|l]%
\Z\.{'\~'};{}$ ${}\|l\PP){}$\5
${}\{{}$\1\6
\&{if} ${}(\|l>\T{7}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Variable\ name\ "}\|O\.{".9s...\ in\ the\
claus}\)\.{e\ on\ line\ "}\|O\.{"lld\ is\ too\ long!\\n"},\39\\{buf}+\|j,\39%
\\{clauses});{}$\6
${}\\{exit}({-}\T{8});{}$\6
\4${}\}{}$\2\6
${}\|h\MRL{{\XOR}{\K}}\\{hash\_bits}[\\{buf}[\|j+\|l]-\.{'!'}][\|l];{}$\6
${}\\{cur\_tmp\_var}\MG\\{name}.\\{ch8}[\|l]\K\\{buf}[\|j+\|l];{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\|l\E\T{0}){}$\1\5
\&{goto} \\{empty\_clause};\C{ `\.\~' by itself is like `true' }\2\6
${}\|j\MRL{+{\K}}\|l;{}$\6
${}\|h\MRL{\AND{\K}}(\T{1}\LL\\{hbits})-\T{1}{}$;\par
\Us15\ET79.\fi

\M{20}\B\X20:Find \PB{$\\{cur\_tmp\_var}\MG\\{name}$} in the hash table at \PB{%
\|p}\X${}\E{}$\6
\&{for} ${}(\|p\K\\{hash}[\|h];{}$ \|p; ${}\|p\K\|p\MG\\{next}){}$\1\6
\&{if} ${}(\|p\MG\\{name}.\\{lng}\E\\{cur\_tmp\_var}\MG\\{name}.\\{lng}){}$\1\5
\&{break};\2\2\6
\&{if} ${}(\R\|p){}$\5
${}\{{}$\C{ new variable found }\1\6
${}\|p\K\\{cur\_tmp\_var}\PP;{}$\6
${}\|p\MG\\{next}\K\\{hash}[\|h],\39\\{hash}[\|h]\K\|p;{}$\6
${}\|p\MG\\{serial}\K\\{vars}\PP;{}$\6
${}\|p\MG\\{stamp}\K\T{0};{}$\6
\4${}\}{}$\2\par
\U15.\fi

\M{21}The most interesting aspect of the input phase is probably the
``unwinding''
that we might need to do when encountering a literal more than once
in the same clause.

\Y\B\4\X21:Handle a duplicate literal\X${}\E{}$\6
${}\{{}$\1\6
\&{if} ${}((\|p\MG\\{stamp}>\T{0})\E(\|i>\T{0})){}$\1\5
\&{goto} \\{empty\_clause};\2\6
\4${}\}{}$\2\par
\U15.\fi

\M{22}An input line that begins with `\.{\~\ }' is silently treated as a
comment.
Otherwise redundant clauses are logged, in case they were unintentional.
(One can, however, intentionally
use redundant clauses to force the order of the variables.)

\Y\B\4\X22:Remove all variables of the current clause\X${}\E{}$\6
\&{while} (\|k)\5
${}\{{}$\1\6
\X23:Move \PB{\\{cur\_cell}} backward to the previous cell\X;\6
${}\|k\MM;{}$\6
\4${}\}{}$\2\6
\&{if} ${}((\\{buf}[\T{0}]\I\.{'\~'})\V(\\{buf}[\T{1}]\I\.{'\ '})){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"(The\ clause\ on\ line}\)\.{\ "}\|O\.{"lld\ is%
\ always\ satis}\)\.{fied)\\n"},\39\\{clauses});{}$\2\6
${}\\{nullclauses}\PP{}$;\par
\U14.\fi

\M{23}\B\X23:Move \PB{\\{cur\_cell}} backward to the previous cell\X${}\E{}$\6
\&{if} ${}(\\{cur\_cell}>{\AND}\\{cur\_chunk}\MG\\{cell}[\T{0}]){}$\1\5
${}\\{cur\_cell}\MM;{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{register} \&{chunk} ${}{*}\\{old\_chunk}\K\\{cur\_chunk};{}$\7
${}\\{cur\_chunk}\K\\{old\_chunk}\MG\\{prev}{}$;\5
\\{free}(\\{old\_chunk});\6
${}\\{bad\_cell}\K{\AND}\\{cur\_chunk}\MG\\{cell}[\\{cells\_per\_chunk}];{}$\6
${}\\{cur\_cell}\K\\{bad\_cell}-\T{1};{}$\6
\4${}\}{}$\2\par
\Us22\ET50.\fi

\M{24}\B\X24:Move \PB{\\{cur\_tmp\_var}} backward to the previous temporary
variable\X${}\E{}$\6
\&{if} ${}(\\{cur\_tmp\_var}>{\AND}\\{cur\_vchunk}\MG\\{var}[\T{0}]){}$\1\5
${}\\{cur\_tmp\_var}\MM;{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{register} \&{vchunk} ${}{*}\\{old\_vchunk}\K\\{cur\_vchunk};{}$\7
${}\\{cur\_vchunk}\K\\{old\_vchunk}\MG\\{prev}{}$;\5
\\{free}(\\{old\_vchunk});\6
${}\\{bad\_tmp\_var}\K{\AND}\\{cur\_vchunk}\MG\\{var}[\\{vars\_per%
\_vchunk}];{}$\6
${}\\{cur\_tmp\_var}\K\\{bad\_tmp\_var}-\T{1};{}$\6
\4${}\}{}$\2\par
\U54.\fi

\M{25}\B\X25:Report the successful completion of the input phase\X${}\E{}$\6
$\\{fprintf}(\\{stderr},\39\.{"("}\|O\.{"lld\ variables,\ "}\|O\.{"lld\
clauses,\ "}\|O\.{"llu\ literals\ succes}\)\.{sfully\ read)\\n"},\39\\{vars},%
\39\\{clauses},\39\\{cells}){}$;\par
\U2.\fi

\N{1}{26}SAT solving, version 13.
The methods used in this program have much in common with what we've
seen before in {\mc SAT0}, {\mc SAT1}, etc.; yet conflict-driven
clause learning is also rather different. So we might as well derive everything
from first principles.

As usual, our goal is to find strictly distinct literals that satisfy
all of the given clauses, or to prove that those clauses can't all be
satisfied. Thus our subgoal, after having created a ``trail'' $l_0l_1\ldots
l_t$
of literals that don't falsify any clause, will be to extend that sequence
until finding a solution, and to do this without failing unless no
solution exists.

If there's a clause $c$ of the form $l\lor\bar a_1\lor\cdots\lor\bar a_k$,
where $a_1$ through~$a_k$ are in the trail but $l$ isn't, we append~$l$
to the trail and say that $c$ is its ``reason.'' This operation, often
called unit propagation, is basic to our program; we shall simply call
it {\it forcing}. (We're forced to make $l$ true, if $a_1$ through $a_k$
are true, because $c$ must be satisfied.) A {\it conflict\/} occurs
if the complementary literal $\bar l$ is already in the trail,
because $l$ can't be both true and false;
but let's assume for now that no conflicts arise.

If no such forcing clause exists, and if the clauses aren't all satisfied,
we choose a new distinct literal in some heuristic way, and append it to
the trail with a ``reason'' of~0. Such literals are called {\it decisions}.
They partition the trail into a sequence of decision levels, with
literal $l_j$ belonging to level~$d$ if and only if $i_d\le j< i_{d+1}$.
In general $0\le i_1<i_2<\cdots{}$; and we also define $i_0=0$.
(Level~0 is special; it contains literals that are forced by clauses of
length~1, if such clauses exist. Any such literals are unconditionally true.
Every other level begins with exactly one decision.)

\def\sucp{\mathrel{{\succ}\!^+}}
If the reason for $l$ includes the literal $\bar l'$, we say
``$l$ depends directly on~$l'$,'' and we write $l\succ l'$.
And if there's a chain of one or more direct dependencies
$l\succ l_1\succ\cdots\succ l_k=l'$, we write $l\sucp l'$ and
say simply that ``$l$ depends on~$l'$.'' For example, given the
three clauses $a$ and $\bar a\lor b$ and $\bar b\lor\bar c\lor d$,
we might begin the trail with $l_0l_1l_2l_3=abcd$, where the first clause
is the reason for~$a$, the second clause is the reason for~$b$, and the
third clause is the reason for~$d$, while $c$ is a decision.
Then $d\succ c$ and $d\succ b$ and $b\succ a$; hence $d\sucp a$.

Notice that a literal can depend only on literals that precede it in the trail.
Furthermore,
every literal $l$ that's forced at level $d>0$ depends directly on some
{\it other\/} literal on that same level; hence $l$ must necessarily
depend on the $d\,$th decision.

The reason for reasons is that we need to deal with conflicts. We will see
that every conflict allows us to construct a new clause~$c$ that must be
true whenever the existing clauses are satisfiable, although $c$ itself
does not contain any existing clause. Therefore we can ``learn''~$c$ by
adding it to the existing clauses, and we can try again. This learning
process can't go on forever, because only finitely many clauses are possible.
Sooner or later we will therefore either find a solution or learn the
empty clause.

A conflict clause $c_d$ on decision level~$d$ has the form
$\bar l\lor\bar a_1\lor\cdots\lor\bar a_k$, where $l$ and all the $a$'s
belong to the trail; furthermore $l$ and at least one $a_i$ belong to
level~$d$. We can assume that $l$ is rightmost in the trail,
of all the literals in $c_d$.
Hence $l$ cannot be the $d\,$th decision; and it has a
reason, say $l\lor\bar a'_1\lor\cdots\lor\bar a'_{k'}$. Resolving $c_d$
with this reason gives the clause $c=\bar a_1\lor\cdots\lor\bar a_k\lor\bar
a'_1\lor\cdots\lor\bar a'_{k'}$, which includes at least one literal~$\bar l'$
for which $l'$ is on level~$d$. If more than one such literal is present,
we can resolve $c$ with the reason of a rightmost~$l'$;
the result will involve negations of literals that are still further
to the left. By repeating this process we'll eventually obtain
$c$ of the form $\bar l'\lor\bar b_1\lor\cdots\lor\bar b_r$, where
$l'$ is on level~$d$ and where $b_1$ through~$b_r$ are on lower levels.

Such a $c$ is learnable, as desired, because it can't contain any
existing clause. (Every subclause of~$c$, including $c$ itself,
would have given us something to
force at a lower level.) We can now discard levels $>d'$ of the trail, where
$d'$ is the maximum level of $b_1$ through $b_r$; and we append
$\bar l'$ to the end of level~$d'$, with $c$ as its reason.
The forcing process now resumes at level~$d'$, as if the learned
clause had been present all along.

Okay, that's the basic idea of conflict-driven clause learning.
Many other issues will come up as we refine it, of course. For example,
we'll see that the clause $c$ can often be simplified by removing
one or more of its literals~$\bar b_i$. And we'll want to ``unlearn'' clauses
that outlive their usefulness.

\fi

\M{27}What data structures support this procedure? We obviously need to
represent the trail, as well as the levels, the values, and the reasons for
each of its literals.

A principal concern is to make forcing as fast as possible. Many
applications involve numerous binary clauses (that is, clauses of length~2);
and binary clauses make forcing quite easy. So we should have a
special mechanism to derive binary implications quickly.

Long clauses are also important. (Even if they aren't common in the input,
the clauses that we learn may well turn out to involve dozens of literals.)
``Watch lists'' provide a good way to recognize when such clauses
become ready for forcing: We choose two literals in each long clause,
neither of which is false, and we pay no attention to that clause until one of
its watched literals becomes false. In the latter case, we'll be able to
watch it with another literal, unless the clause has become true or it's ready
to force something. (We've used a similar idea, but with only one watched
literal per clause, in {\mc SAT0W} and {\mc SAT10}.)

We'll want a good heuristic for choosing the decision literals.
This program adopts the strategy of E\'en and S\"orensson's
MiniSAT, which associates a floating-point {\it activity\/}
score with each variable, and uses a heap to choose the most
active variable.

Learned clauses also have a measure of clause quality devised by Gilles
Audemard
and Laurent Simon. The original clauses are static and stay in place,
but we must periodically decide which of the learned clauses to keep.

\Y\B\4\X4:Global variables\X${}\mathrel+\E{}$\6
\&{cel} ${}{*}\\{mem}{}$;\C{ master array of clause data }\6
\&{uint} \\{memsize};\C{ the number of cells allocated for it }\6
\&{uint} \\{min\_learned};\C{ boundary between original and learned clauses }\6
\&{uint} \\{first\_learned};\C{ address of the first learned clause }\6
\&{uint} \\{max\_learned};\C{ the first unused position of \PB{\\{mem}} }\6
\&{int} \\{max\_lit};\C{ value of the largest legal literal }\6
\&{uint} ${}{*}\\{bmem}{}$;\C{ binary clause data }\6
\&{literal} ${}{*}\\{lmem}{}$;\C{ attributes of literals }\6
\&{variable} ${}{*}\\{vmem}{}$;\C{ attributes of variables }\6
\&{uint} ${}{*}\\{heap}{}$;\C{ priority queue for sorting variables by their
activity }\6
\&{int} \\{hn};\C{ number of items currently in the heap }\6
\&{uint} ${}{*}\\{trail}{}$;\C{ literals currently assumed, or forced by those
assumptions }\6
\&{int} \\{eptr};\C{ just past the end of the trail }\6
\&{int} \\{ebptr};\C{ just past where binary propagations haven't been done yet
}\6
\&{int} \\{lptr};\C{ just past where we've checked nonbinary propagations }\6
\&{int} \\{lbptr};\C{ just past where we've checked binary propagations }\6
\&{char} ${}{*}\\{history}{}$;\C{ type of assertion, for diagnostic printouts }%
\6
\&{int} \\{llevel};\C{ twice the current level }\6
\&{int} ${}{*}\\{leveldat}{}$;\C{ where levels begin; also conflict data on
full runs }\par
\fi

\M{28}Binary clauses $u\lor v$ are represented by putting $v$ into a list
associated with $\bar u$ and $u$ into a list associated with $\bar v$.
These ``binary implication'' lists are created once and for all at the
beginning of the run, as explained below.

Longer clauses (and binary clauses that are learned later) are
represented in a big array \PB{\\{mem}} of 32-bit integers. (Entries of \PB{%
\\{mem}}
are often called ``cells'' in this documentation.) The literals
of clause~\PB{\|c} are \PB{$\\{mem}[\|c].\\{lit}$}, \PB{$\\{mem}[\|c+\T{1}].%
\\{lit}$}, \PB{$\\{mem}[\|c+\T{2}].\\{lit}$}, etc.;
the first two of these are ``watching''~$c$. The number of literals,
\PB{\\{size}(\|c)}, is \PB{$\\{mem}[\|c-\T{1}].\\{lit}$}; and we keep links to
other clauses
being watched by the same literals in \PB{$\\{link0}(\|c)\K\\{mem}[\|c-\T{2}].%
\\{lit}$} and
\PB{$\\{link1}(\|c)\K\\{mem}[\|c-\T{3}].\\{lit}$}.

(Incidentally, this linked structure for watch lists was originally introduced
in PicoSAT by Armin Biere [{\sl Journal on Satisfiability, Boolean Modeling
and Computation\/ \bf4} (2008), 75--97]. Nowadays the fastest solvers
use a more complicated mechanism called ``blocking literals,'' due to Niklas
S\"orensson, which is faster because it is more cache friendly. However,
I'm sticking to linked lists, because (1)~they don't need dynamic storage
allocation of sequential arrays; (2)~they use fewer memory accesses; and
(3)~on modern multithreaded machines they can be implemented so as to avoid the
cache misses, by starting up threads whose sole purpose is to preload the
link-containing cells into the cache. I~expect that software to facilitate
such transformations will be widely available before long.)

Sometimes we learn that a clause can be strengthened by removing
one of its literals. In such cases we add \PB{\\{sign\_bit}} to the surplus
literal, swap it to the end of the clause, and decrease the \PB{\\{size}}
field.
Except for such deleted literals, the sign bit of every cell in \PB{\\{mem}}
should
be zero. (The earliest cell of a learned clause~\PB{\|c} is the nonnegative
floating-point value \PB{\\{activ}(\|c)}.
The final clause should be followed by a zero cell,
so that garbage at the end isn't confused with a deleted literal.)

If \PB{\|c} is the current reason for literal \PB{\|l}, its first literal
\PB{$\\{mem}[\|c].\\{lit}$} is always equal to \PB{\|l}. This condition makes
it easy
to tell if a given clause plays an important role in the current trail.

A learned clause is identifiable by the condition \PB{$\|c\G\\{min\_learned}$}.
Such clauses have additional information,
\PB{$\\{range}(\|c)\K\\{mem}[\|c-\T{4}].\\{lit}$} and \PB{$\\{activ}(\|c)\K%
\\{mem}[\|c-\T{5}].\\{flt}$},
which will help us decide whether
or not to keep them after memory has begun to fill up.

\Y\B\4\D$\\{size}(\|c)$ \5
$\\{mem}[(\|c)-\T{1}].{}$\\{lit}\par
\B\4\D$\\{link0}(\|c)$ \5
$\\{mem}[(\|c)-\T{2}].{}$\\{lit}\par
\B\4\D$\\{link1}(\|c)$ \5
$\\{mem}[(\|c)-\T{3}].{}$\\{lit}\par
\B\4\D$\\{clause\_extra}$ \5
\T{3}\C{ every clause has a 3-cell preamble }\par
\B\4\D$\\{sign\_bit}$ \5
\T{\^80000000}\par
\B\4\D$\\{range}(\|c)$ \5
$\\{mem}[(\|c)-\T{4}].{}$\\{lit}\par
\B\4\D$\\{activ}(\|c)$ \5
$\\{mem}[(\|c)-\T{5}].{}$\\{flt}\par
\B\4\D$\\{activ\_as\_lit}(\|c)$ \5
((\&{ullng}) \\{mem}${}[(\|c)-\T{5}].\\{lit}\LL\T{32}{}$)\par
\B\4\D$\\{learned\_supplement}$ \5
\T{2}\C{ learned clauses have this many more cells in their preamble }\par
\B\4\D$\\{learned\_extra}$ \5
$(\\{clause\_extra}+\\{learned\_supplement}{}$)\C{ preamble length }\par
\Y\B\4\X9:Type definitions\X${}\mathrel+\E{}$\6
\&{typedef} \&{union} ${}\{{}$\1\6
\&{uint} \\{lit};\6
\&{float} \\{flt};\2\6
${}\}{}$ \&{cel};\par
\fi

\M{29}The variables are numbered from 1 to \PB{\|n}. The literals corresponding
to variable~\PB{\|k} are \PB{$\|k+\|k$} and \PB{$\|k+\|k+\T{1}$}, standing
respectively for $v$
and $\bar v$ if the $k$th variable is~$v$.

Several different kinds of data are maintained for each variable:
its eight-character \PB{\\{name}}; its \PB{\\{activity}} score (used to
indicate
relative desirability for being chosen to make the next decision);
its current \PB{\\{value}}, which also encodes the level at which
the value was set; its current location, \PB{\\{tloc}}, in the trail;
and its current location, \PB{\\{hloc}}, in the heap
(which is used to find a maximum activity score). There's also
\PB{\\{oldval}} and \PB{\\{stamp}}, which will be explained later.

\Y\B\4\D$\\{bar}(\|l)$ \5
$((\|l)\XOR\T{1}{}$)\par
\B\4\D$\\{thevar}(\|l)$ \5
$((\|l)\GG\T{1}{}$)\par
\B\4\D$\\{litname}(\|l)$ \5
$(\|l)\AND\T{1}\?\.{"\~"}:\.{""},\39\\{vmem}[\\{thevar}(\|l)].\\{name}.{}$%
\\{ch8}\C{ used in printouts }\par
\B\4\D$\\{poslit}(\|v)$ \5
$((\|v)\LL\T{1}{}$)\par
\B\4\D$\\{neglit}(\|v)$ \5
$(((\|v)\LL\T{1})+\T{1}{}$)\par
\B\4\D$\\{unset}$ \5
\T{\^ffffffff}\C{ value when the variable hasn't been assigned }\par
\B\4\D$\\{isknown}(\|l)$ \5
$(\\{vmem}[\\{thevar}(\|l)].\\{value}\I\\{unset}{}$)\par
\B\4\D$\\{iscontrary}(\|l)$ \5
$((\\{vmem}[\\{thevar}(\|l)].\\{value}\XOR(\|l))\AND\T{1}{}$)\par
\Y\B\4\X9:Type definitions\X${}\mathrel+\E{}$\6
\&{typedef} \&{struct} ${}\{{}$\1\6
\&{octa} \\{name};\6
\&{double} \\{activity};\6
\&{uint} \\{value};\6
\&{int} \\{tloc};\6
\&{int} \\{hloc};\C{ is \PB{${-}\T{1}$} if the variable isn't in the heap }\6
\&{uint} \\{oldval};\6
\&{uint} \\{stamp};\6
\&{uint} \\{filler};\C{ not used, but gives octabyte alignment }\2\6
${}\}{}$ \&{variable};\par
\fi

\M{30}Special data for each literal goes into \PB{\\{lmem}}, containing the
literal's
\PB{\\{reason}} for being true, the first clause (if any) that it watches,
and the boundaries of its binary implications in \PB{\\{bmem}}.

\Y\B\4\X9:Type definitions\X${}\mathrel+\E{}$\6
\&{typedef} \&{struct} ${}\{{}$\1\6
\&{int} \\{reason};\C{ is negative for binary reasons, otherwise clause number
}\6
\&{uint} \\{watch};\C{ head of the list of clauses watched by this literal }\6
\&{uint} \\{bimp\_start};\C{ where binary implications begin in \PB{\\{bmem}} }%
\6
\&{uint} \\{bimp\_end};\C{ just after where they end (or zero if there aren't
any) }\2\6
${}\}{}$ \&{literal};\par
\fi

\M{31}Here is a subroutine that prints the binary implicant data for
a given literal. (Used only when debugging.)

\Y\B\4\X31:Subroutines\X${}\E{}$\6
\&{void} \\{print\_bimp}(\&{int} \|l)\1\1\2\2\6
${}\{{}$\1\6
\&{register} \&{uint} \\{la};\7
${}\\{printf}(\.{""}\|O\.{"s"}\|O\.{".8s("}\|O\.{"d)\ ->"},\39\\{litname}(\|l),%
\39\|l);{}$\6
\&{if} ${}(\\{lmem}[\|l].\\{bimp\_end}){}$\5
${}\{{}$\1\6
\&{for} ${}(\\{la}\K\\{lmem}[\|l].\\{bimp\_start};{}$ ${}\\{la}<\\{lmem}[\|l].%
\\{bimp\_end};{}$ ${}\\{la}\PP){}$\1\5
${}\\{printf}(\.{"\ "}\|O\.{"s"}\|O\.{".8s("}\|O\.{"d)"},\39\\{litname}(%
\\{bmem}[\\{la}]),\39\\{bmem}[\\{la}]);{}$\2\6
\4${}\}{}$\2\6
\\{printf}(\.{"\\n"});\6
\4${}\}{}$\2\par
\As32, 33, 34, 39, 42, 43, 44\ETs71.
\U2.\fi

\M{32}Similarly, we can print the numbers of all clauses that \PB{\|l} is
currently
watching.

\Y\B\4\X31:Subroutines\X${}\mathrel+\E{}$\6
\&{void} \\{print\_watches\_for}(\&{int} \|l)\1\1\2\2\6
${}\{{}$\1\6
\&{register} \&{uint} \|c;\7
${}\\{printf}(\.{""}\|O\.{"s"}\|O\.{".8s("}\|O\.{"d)\ watched\ in"},\39%
\\{litname}(\|l),\39\|l);{}$\6
\&{for} ${}(\|c\K\\{lmem}[\|l].\\{watch};{}$ \|c; \,)\5
${}\{{}$\1\6
${}\\{printf}(\.{"\ "}\|O\.{"u"},\39\|c);{}$\6
\&{if} ${}(\\{mem}[\|c].\\{lit}\E\|l){}$\1\5
${}\|c\K\\{link0}(\|c);{}$\2\6
\&{else}\1\5
${}\|c\K\\{link1}(\|c);{}$\2\6
\4${}\}{}$\2\6
\\{printf}(\.{"\\n"});\6
\4${}\}{}$\2\par
\fi

\M{33}And we also sometimes need to see the literals of a given clause.

\Y\B\4\X31:Subroutines\X${}\mathrel+\E{}$\6
\&{void} \\{print\_clause}(\&{uint} \|c)\1\1\2\2\6
${}\{{}$\1\6
\&{register} \&{int} \|k${},{}$ \|l;\7
${}\\{printf}(\.{""}\|O\.{"u:"},\39\|c);{}$\6
\&{if} ${}(\|c<\\{clause\_extra}\V\|c\G\\{max\_learned}){}$\5
${}\{{}$\1\6
${}\\{printf}(\.{"\ clause\ "}\|O\.{"d\ doesn't\ exist!\\n"},\39\|c);{}$\6
\&{return};\6
\4${}\}{}$\2\6
\&{for} ${}(\|k\K\T{0};{}$ ${}\|k<\\{size}(\|c);{}$ ${}\|k\PP){}$\5
${}\{{}$\1\6
${}\|l\K\\{mem}[\|c+\|k].\\{lit};{}$\6
\&{if} ${}(\|l<\T{2}\V\|l>\\{max\_lit}){}$\5
${}\{{}$\1\6
\\{printf}(\.{"\ BAD!\\n"});\6
\&{return};\6
\4${}\}{}$\2\6
${}\\{printf}(\.{"\ "}\|O\.{"s"}\|O\.{".8s("}\|O\.{"u)"},\39\\{litname}(\|l),%
\39\|l);{}$\6
\4${}\}{}$\2\6
\&{while} ${}(\\{mem}[\|c+\|k].\\{lit}\AND\\{sign\_bit}){}$\5
${}\{{}$\1\6
${}\|l\K\\{mem}[\|c+\|k].\\{lit}\XOR\\{sign\_bit};{}$\6
\&{if} ${}(\|l<\T{2}\V\|l>\\{max\_lit}){}$\5
${}\{{}$\1\6
\\{printf}(\.{"\ !BAD!\\n"});\6
\&{return};\6
\4${}\}{}$\2\6
${}\\{printf}(\.{"\ !"}\|O\.{"s"}\|O\.{".8s("}\|O\.{"u)"},\39\\{litname}(\|l),%
\39\|l);{}$\6
${}\|k\PP;{}$\6
\4${}\}{}$\2\6
\\{printf}(\.{"\\n"});\6
\4${}\}{}$\2\par
\fi

\M{34}Speaking of debugging, here's a routine to check if the redundant
parts of our data structure have gone awry.

\Y\B\4\D$\\{sanity\_checking}$ \5
\T{0}\C{ set this to 1 if you suspect a bug }\par
\Y\B\4\X31:Subroutines\X${}\mathrel+\E{}$\6
\&{void} \\{sanity}(\&{int} \\{eptr})\1\1\2\2\6
${}\{{}$\1\6
\&{register} \&{uint} \|k${},{}$ \|l${},{}$ \|c${},{}$ \\{endc}${},{}$ %
\|u${},{}$ \|v${},{}$ \\{clauses}${},{}$ \\{watches}${},{}$ \\{vals}${},{}$ %
\\{llevel};\7
\X35:Check all clauses for spurious data\X;\6
\X36:Check the watch lists\X;\6
\X72:Check the sanity of the heap\X;\6
\X37:Check the trail\X;\6
\X38:Check the variables\X;\6
\4${}\}{}$\2\par
\fi

\M{35}\B\X35:Check all clauses for spurious data\X${}\E{}$\6
\&{for} ${}(\\{clauses}\K\|k\K\T{0},\39\|c\K\\{clause\_extra};{}$ ${}\|c<\\{min%
\_learned};{}$ ${}\|k\K\|c,\39\|c\K\\{endc}+\\{clause\_extra}){}$\5
${}\{{}$\1\6
${}\\{endc}\K\|c+\\{size}(\|c);{}$\6
${}\\{clauses}\PP;{}$\6
\&{if} ${}(\\{link0}(\|c)\G\\{max\_learned}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"bad\ link0("}\|O\.{"u)!\\n"},\39\|c);{}$\6
\&{return};\6
\4${}\}{}$\2\6
\&{if} ${}(\\{link1}(\|c)\G\\{max\_learned}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"bad\ link1("}\|O\.{"u)!\\n"},\39\|c);{}$\6
\&{return};\6
\4${}\}{}$\2\6
\&{if} ${}(\\{size}(\|c)<\T{2}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"size("}\|O\.{"u)="}\|O\.{"d!\\n"},\39\|c,\39%
\\{size}(\|c));{}$\2\6
\&{for} ${}(\|k\K\T{0};{}$ ${}\|k<\\{size}(\|c);{}$ ${}\|k\PP){}$\1\6
\&{if} ${}(\\{mem}[\|c+\|k].\\{lit}<\T{2}\V\\{mem}[\|c+\|k].\\{lit}>\\{max%
\_lit}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"bad\ lit\ "}\|O\.{"d\ of\ "}\|O\.{"d!\\n"},\39%
\|k,\39\|c);{}$\2\2\6
\&{while} ${}(\\{mem}[\|c+\|k].\\{lit}\AND\\{sign\_bit}){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{mem}[\|c+\|k].\\{lit}<\T{2}+\\{sign\_bit}\V\\{mem}[\|c+\|k].%
\\{lit}>\\{max\_lit}+\\{sign\_bit}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"bad\ deleted\ lit\ "}\|O\.{"d\ of\ "}\|O\.{"d!%
\\n"},\39\|k,\39\|c);{}$\2\6
${}\|k\PP,\39\\{endc}\PP;{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{if} ${}(\|c\I\\{min\_learned}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"bad\ last\ unlearned\ }\)\.{clause\ ("}\|O%
\.{"d)!\\n"},\39\|k);{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{for} ${}(\|k\K\T{0},\39\|c\K\\{first\_learned};{}$ ${}\|c<\\{max%
\_learned};{}$ ${}\|k\K\|c,\39\|c\K\\{endc}+\\{learned\_extra}){}$\5
${}\{{}$\1\6
${}\\{endc}\K\|c+\\{size}(\|c);{}$\6
${}\\{clauses}\PP;{}$\6
\&{if} ${}(\\{link0}(\|c)\G\\{max\_learned}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"bad\ link0("}\|O\.{"u)!\\n"},\39\|c);{}$\6
\&{return};\6
\4${}\}{}$\2\6
\&{if} ${}(\\{link1}(\|c)\G\\{max\_learned}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"bad\ link1("}\|O\.{"u)!\\n"},\39\|c);{}$\6
\&{return};\6
\4${}\}{}$\2\6
\&{if} ${}(\\{size}(\|c)<\T{2}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"size("}\|O\.{"u)="}\|O\.{"d!\\n"},\39\|c,\39%
\\{size}(\|c));{}$\2\6
\&{for} ${}(\|k\K\T{0};{}$ ${}\|k<\\{size}(\|c);{}$ ${}\|k\PP){}$\1\6
\&{if} ${}(\\{mem}[\|c+\|k].\\{lit}<\T{2}\V\\{mem}[\|c+\|k].\\{lit}>\\{max%
\_lit}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"bad\ lit\ "}\|O\.{"d\ of\ "}\|O\.{"d!\\n"},\39%
\|k,\39\|c);{}$\2\2\6
\&{while} ${}(\\{mem}[\|c+\|k].\\{lit}\AND\\{sign\_bit}){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{mem}[\|c+\|k].\\{lit}<\T{2}+\\{sign\_bit}\V\\{mem}[\|c+\|k].%
\\{lit}>\\{max\_lit}+\\{sign\_bit}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"bad\ deleted\ lit\ "}\|O\.{"d\ of\ "}\|O\.{"d!%
\\n"},\39\|k,\39\|c);{}$\2\6
${}\|k\PP,\39\\{endc}\PP;{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{if} ${}(\|c\I\\{max\_learned}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"bad\ last\ learned\ cl}\)\.{ause\ ("}\|O%
\.{"d)!\\n"},\39\|k);{}$\2\6
\&{if} ${}(\\{mem}[\|c-\\{learned\_extra}].\\{lit}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"missing\ zero\ at\ end}\)\.{\ of\ mem!%
\\n"});{}$\2\6
\4${}\}{}$\2\par
\U34.\fi

\M{36}In really bad cases this routine will get into a loop. I try to avoid
segmentation faults, but not loops.

\Y\B\4\X36:Check the watch lists\X${}\E{}$\6
\&{for} ${}(\\{watches}\K\T{0},\39\|l\K\T{2};{}$ ${}\|l\Z\\{max\_lit};{}$ ${}%
\|l\PP){}$\5
${}\{{}$\1\6
\&{for} ${}(\|c\K\\{lmem}[\|l].\\{watch};{}$ \|c; \,)\5
${}\{{}$\1\6
${}\\{watches}\PP;{}$\6
\&{if} ${}(\|c<\\{clause\_extra}\V\|c\G\\{max\_learned}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"clause\ "}\|O\.{"u\ in\ watch\ list\ "}\|O%
\.{"u\ out\ of\ range!\\n"},\39\|c,\39\|l);{}$\6
\&{return};\6
\4${}\}{}$\2\6
\&{if} ${}(\\{mem}[\|c].\\{lit}\E\|l){}$\1\5
${}\|c\K\\{link0}(\|c);{}$\2\6
\&{else} \&{if} ${}(\\{mem}[\|c+\T{1}].\\{lit}\E\|l){}$\1\5
${}\|c\K\\{link1}(\|c);{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"clause\ "}\|O\.{"u\ improperly\ on\ wat}\)%
\.{ch\ list\ "}\|O\.{"u!\\n"},\39\|c,\39\|l);{}$\6
\&{return};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{if} ${}(\\{watches}\I\\{clauses}+\\{clauses}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{""}\|O\.{"u\ clauses\ but\ "}\|O\.{"u\ watches!%
\\n"},\39\\{clauses},\39\\{watches}){}$;\2\par
\U34.\fi

\M{37}\B\X37:Check the trail\X${}\E{}$\6
\&{for} ${}(\|k\K\\{llevel}\K\T{0};{}$ ${}\|k<\\{eptr};{}$ ${}\|k\PP){}$\5
${}\{{}$\1\6
${}\|l\K\\{trail}[\|k];{}$\6
\&{if} ${}(\|l<\T{2}\V\|l>\\{max\_lit}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"bad\ lit\ "}\|O\.{"u\ in\ trail["}\|O\.{"u]!%
\\n"},\39\|l,\39\|k);{}$\6
\&{return};\6
\4${}\}{}$\2\6
\&{if} ${}(\\{vmem}[\\{thevar}(\|l)].\\{tloc}\I\|k){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{""}\|O\.{"s"}\|O\.{".8s\ has\ bad\ tloc\ ("}\|O%
\.{"d\ not\ "}\|O\.{"d)!\\n"},\39\\{litname}(\|l),\39\\{vmem}[\\{thevar}(\|l)].%
\\{tloc},\39\|k);{}$\2\6
\&{if} ${}(\|k\E\\{leveldat}[\\{llevel}+\T{2}]){}$\5
${}\{{}$\1\6
${}\\{llevel}\MRL{+{\K}}\T{2};{}$\6
\&{if} ${}(\\{lmem}[\|l].\\{reason}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{""}\|O\.{"s"}\|O\.{".8s("}\|O\.{"u),\ level\ "}%
\|O\.{"u,\ shouldn't\ have\ r}\)\.{eason!\\n"},\39\\{litname}(\|l),\39\|l,\39%
\\{llevel}\GG\T{1});{}$\2\6
\4${}\}{}$\5
\2\&{else}\5
${}\{{}$\1\6
\&{if} ${}(\\{llevel}\W\R\\{lmem}[\|l].\\{reason}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{""}\|O\.{"s"}\|O\.{".8s("}\|O\.{"u),\ level\ "}%
\|O\.{"u,\ should\ have\ reas}\)\.{on!\\n"},\39\\{litname}(\|l),\39\|l,\39%
\\{llevel}\GG\T{1});{}$\2\6
\4${}\}{}$\2\6
\&{if} ${}(\\{lmem}[\\{bar}(\|l)].\\{reason}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{""}\|O\.{"s"}\|O\.{".8s("}\|O\.{"u),\ level\ "}%
\|O\.{"u,\ comp\ has\ reason!}\)\.{\\n"},\39\\{litname}(\|l),\39\|l,\39%
\\{llevel}\GG\T{1});{}$\2\6
\&{if} ${}(\\{vmem}[\\{thevar}(\|l)].\\{value}\I\\{llevel}+(\|l\AND\T{1})){}$\1%
\5
${}\\{fprintf}(\\{stderr},\39\.{""}\|O\.{"s"}\|O\.{".8s("}\|O\.{"u),\ level\ "}%
\|O\.{"u,\ has\ bad\ value!\\n}\)\.{"},\39\\{litname}(\|l),\39\|l,\39\\{llevel}%
\GG\T{1});{}$\2\6
\&{if} (\\{llevel})\5
${}\{{}$\1\6
\&{if} ${}(\\{lmem}[\|l].\\{reason}\Z\T{0}){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{lmem}[\|l].\\{reason}\E{-}\T{1}\V\\{lmem}[\|l].\\{reason}<{-}%
\\{max\_lit}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{""}\|O\.{"s"}\|O\.{".8s("}\|O\.{"u),\ level\ "}%
\|O\.{"u,\ has\ wrong\ binary}\)\.{\ reason\ ("}\|O\.{"u)!\\n"},\39\\{litname}(%
\|l),\39\|l,\39\\{llevel}\GG\T{1},\39\|c);{}$\2\6
\4${}\}{}$\5
\2\&{else}\5
${}\{{}$\1\6
${}\|c\K\\{lmem}[\|l].\\{reason};{}$\6
\&{if} ${}(\\{mem}[\|c].\\{lit}\I\|l){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{""}\|O\.{"s"}\|O\.{".8s("}\|O\.{"u),\ level\ "}%
\|O\.{"u,\ has\ wrong\ reason}\)\.{\ ("}\|O\.{"u)!\\n"},\39\\{litname}(\|l),\39%
\|l,\39\\{llevel}\GG\T{1},\39\|c);{}$\2\6
${}\|u\K\\{bar}(\\{mem}[\|c+\T{1}].\\{lit});{}$\6
\&{if} ${}(\\{vmem}[\\{thevar}(\|u)].\\{value}\I\\{llevel}+(\|u\AND\T{1})){}$\1%
\5
${}\\{fprintf}(\\{stderr},\39\.{""}\|O\.{"s"}\|O\.{".8s("}\|O\.{"u),\ level\ "}%
\|O\.{"u,\ has\ bad\ reason\ (}\)\.{"}\|O\.{"u)!\\n"},\39\\{litname}(\|l),\39%
\|l,\39\\{llevel}\GG\T{1},\39\|c);{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U34.\fi

\M{38}\B\X38:Check the variables\X${}\E{}$\6
\&{for} ${}(\\{vals}\K\T{0},\39\|v\K\T{1};{}$ ${}\|v\Z\\{vars};{}$ ${}\|v%
\PP){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{vmem}[\|v].\\{value}>\\{llevel}+\T{1}){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{vmem}[\|v].\\{value}\I\\{unset}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"strange\ val\ "}\|O\.{".8s\ (level\ "}\|O%
\.{"u)!\\n"},\39\\{vmem}[\|v].\\{name}.\\{ch8},\39\\{vmem}[\|v].\\{value}\GG%
\T{1});{}$\2\6
\&{else} \&{if} ${}(\\{vmem}[\|v].\\{hloc}<\T{0}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{""}\|O\.{".8s\ should\ be\ in\ th}\)\.{e\ heap!%
\\n"},\39\\{vmem}[\|v].\\{name}.\\{ch8});{}$\2\6
\4${}\}{}$\5
\2\&{else}\1\5
${}\\{vals}\PP;{}$\2\6
\4${}\}{}$\2\6
\&{if} ${}(\\{vals}\I\\{eptr}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"I\ found\ "}\|O\.{"u\ values,\ but\ eptr=}\)%
\.{"}\|O\.{"u!\\n"},\39\\{vals},\39\\{eptr}){}$;\2\par
\U34.\fi

\M{39}The \PB{\\{print\_stats}} subroutine presents a digest of the current
goings-on.
First it shows the number of literals learned at level~zero~(\.z).
Then it shows recent smoothed-average values of decision depth~(\.d),
mems per conflict~(\.m),
propagations per conflict~(\.p),
resolutions per conflict~(\.r),
literals per learned clause~(\.L and
\.l, where the latter is restricted to nontrivial clauses),
glucose per learned clause (\.g), and
clauses of length six~or~less per learned clause (\.s),
together with the recent agility~(\.a). For my own edification
I also estimate mems per propagation~(\.{m/p}).

\Y\B\4\D$\\{two\_to\_the\_32}$ \5
\T{4294967296.0}\par
\Y\B\4\X31:Subroutines\X${}\mathrel+\E{}$\6
\&{void} \\{print\_stats}(\&{void})\1\1\2\2\6
${}\{{}$\1\6
\&{register} \&{double} \\{mpc}${}\K\\{mems\_per\_confl},{}$ \\{ppc}${}\K%
\\{props\_per\_confl};{}$\7
${}\\{fprintf}(\\{stderr},\39\.{"z="}\|O\.{"d\ d="}\|O\.{".1f\ t="}\|O\.{".1f\
m="}\|O\.{".1f\ p="}\|O\.{".1f\ m/p="}\|O\.{".1f"},\39\\{leveldat}[\T{2}],%
\39{}$(\&{double}) \\{depth\_per\_decision}${}/\\{two\_to\_the\_32},\39{}$(%
\&{double}) \\{trail\_per\_decision}${}/\\{two\_to\_the\_32},\39\\{mpc}/\\{two%
\_to\_the\_32},\39\\{ppc}/\\{two\_to\_the\_32},\39\\{mpc}/\\{ppc});{}$\6
${}\\{fprintf}(\\{stderr},\39\.{"\ r="}\|O\.{".1f\ L="}\|O\.{".1f\ l="}\|O%
\.{".1f\ g="}\|O\.{".1f\ s="}\|O\.{".2f\ a="}\|O\.{".2f\\n"},\39{}$(\&{double})
\\{res\_per\_confl}${}/\\{two\_to\_the\_32},\39{}$(\&{double}) \\{lits\_per%
\_confl}${}/\\{two\_to\_the\_32},\39{}$(\&{double}) \\{lits\_per\_nontriv}${}/%
\\{two\_to\_the\_32},\39{}$(\&{double}) \\{glucose\_per\_confl}${}/\\{two\_to%
\_the\_32},\39{}$(\&{double}) \\{short\_per\_confl}${}/\\{two\_to\_the\_32},%
\39{}$(\&{double}) \\{agility}${}/\\{two\_to\_the\_32});{}$\6
\4${}\}{}$\2\par
\fi

\M{40}We represent the statistics $\sigma=(x_0+x_1\zeta+x_2\zeta^2+\cdots{})/
(1+\zeta+\zeta^2+\cdots{})$, for various integer quantities~$x$, as
64-bit unsigned integers with 32 bits of fraction. Here $x_k$ denotes
the value of~$x$ at the $k$-from-last conflict, and $\zeta$ is the
damping factor $1-2^{-7}$.

Thus, to update $\sigma$ with a new value of $x$ at conflict time,
we replace it by $\zeta\sigma+2^{32}x/(1+\zeta+\zeta^2+\cdots{})=
\sigma-\sigma/2^7+2^{25}x$.

\Y\B\4\X40:Update the smoothed-average stats after a clause has been learned%
\X${}\E{}$\6
$\\{mems\_per\_confl}\MRL{+{\K}}{-}(\\{mems\_per\_confl}\GG\T{7})+((\\{mems}-%
\\{mems\_at\_prev\_confl})\LL\T{25});{}$\6
${}\\{mems\_at\_prev\_confl}\K\\{mems};{}$\6
${}\\{props\_per\_confl}\MRL{+{\K}}{-}(\\{props\_per\_confl}\GG\T{7})+{}$((%
\&{ullng}) \\{props}${}\LL\T{25});{}$\6
${}\\{props}\K\T{0};{}$\6
${}\\{res\_per\_confl}\MRL{+{\K}}{-}(\\{res\_per\_confl}\GG\T{7})+{}$((%
\&{ullng}) \\{resols}${}\LL\T{25});{}$\6
${}\\{lits\_per\_confl}\MRL{+{\K}}{-}(\\{lits\_per\_confl}\GG\T{7})+{}$((%
\&{ullng}) \\{learned\_size}${}\LL\T{25});{}$\6
\&{if} ${}(\R\\{trivial\_learning}){}$\1\5
${}\\{lits\_per\_nontriv}\MRL{+{\K}}{-}(\\{lits\_per\_nontriv}\GG\T{7})+{}$((%
\&{ullng}) \\{learned\_size}${}\LL\T{25});{}$\2\6
${}\\{short\_per\_confl}\MRL{+{\K}}{-}(\\{short\_per\_confl}\GG\T{7})+(%
\\{learned\_size}>\T{6}\?\T{0}:\T{1}\LL\T{25});{}$\6
${}\\{glucose\_per\_confl}\MRL{+{\K}}{-}(\\{glucose\_per\_confl}\GG\T{7})+{}$((%
\&{ullng}) \\{clevels}${}\LL\T{25}){}$;\par
\U102.\fi

\M{41}\B\X4:Global variables\X${}\mathrel+\E{}$\6
\&{ullng} \\{depth\_per\_decision};\C{ smoothed average of \PB{$\\{llevel}\GG%
\T{1}$} at decision time }\6
\&{ullng} \\{trail\_per\_decision};\C{ smoothed average of \PB{\\{eptr}} at
decision time }\6
\&{ullng} \\{mems\_per\_confl}${},{}$ \\{lits\_per\_confl}${},{}$ \\{lits\_per%
\_nontriv};\C{ smoothed averages }\6
\&{ullng} \\{res\_per\_confl}${},{}$ \\{glucose\_per\_confl};\C{ more smoothies
}\6
\&{ullng} \\{props\_per\_confl}${}\K\\{two\_to\_the\_32}{}$;\C{ this one ought
to be nonzero }\6
\&{uint} \\{short\_per\_confl};\C{ smoothed probability of learned clause being
short }\6
\&{uint} \\{agility};\C{ smoothed probability of forced flips in value }\6
\&{ullng} \\{mems\_at\_prev\_confl};\C{ mems at the previous update }\6
\&{uint} \\{props};\C{ propagations since the previous update }\par
\fi

\M{42}In long runs it's helpful to know how far we've gotten. A numeric code
summarizes the histories of literals that appear in the current trail:
0 or 1 means that we're trying to set a variable
true or false, as a decision at the beginning of a level;
2 or 3 is similar, but after we've learned that the decision was wrong (hence
we've learned a clause that has forced the opposite decision);
4 or 5 is similar, but when the value was forced by
the decision at the previous decision node;
6 or 7 is similar, but after we learned that a previous decision
forces this one. (In the latter case, the learned clause forced a
variable that was not the decision variable at its level.)
This code is also used for unit clauses in the input.

A special \PB{\\{history}} array is used to provide these base codes (0, 2, 4,
or 6).
No mems are assessed for maintaining \PB{\\{history}}, because it isn't used
in any decisions taken by the algorithm; it's purely for diagnostic purposes.

The variable \PB{\\{trail\_marker}} marks a place in the trail that I'm trying
to study. This subroutine inserts a vertical line at that point, so that
I can watch where it goes. (Maybe other users might even find it informative
some day, who knows?)

Note: These codes are analogous to similar codes in {\mc SAT0}, {\mc SAT0W},
{\mc SAT10}, and {\mc SAT11}. But they don't really give an easy-to-read
picture of progress, as they did in the others, because they don't increase
lexicographically in the presence of restarts. Therefore they are
displayed only if the user has set \PB{\\{print\_state\_cutoff}} to a positive
value, using the command-line parameter~\.H.

\Y\B\4\X31:Subroutines\X${}\mathrel+\E{}$\6
\&{void} \\{print\_state}(\&{int} \\{eptr})\1\1\2\2\6
${}\{{}$\1\6
\&{register} \&{uint} \|j${},{}$ \|k;\7
${}\\{fprintf}(\\{stderr},\39\.{"\ after\ "}\|O\.{"lld\ mems:"},\39%
\\{mems});{}$\6
\&{if} (\\{print\_state\_cutoff})\5
${}\{{}$\1\6
\&{for} ${}(\|k\K\T{0};{}$ ${}\|k<\\{eptr};{}$ ${}\|k\PP){}$\5
${}\{{}$\1\6
\&{if} ${}(\|k\E\\{trail\_marker}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"|"});{}$\2\6
${}\\{fprintf}(\\{stderr},\39\.{""}\|O\.{"d"},\39\\{history}[\|k]+(\\{trail}[%
\|k]\AND\T{1}));{}$\6
\&{if} ${}(\|k\G\\{print\_state\_cutoff}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"..."}){}$;\5
\&{break};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\\{fprintf}(\\{stderr},\39\.{"\\n"});{}$\6
\4${}\}{}$\2\6
${}\\{fprintf}(\\{stderr},\39\.{"\ "});{}$\6
\\{print\_stats}(\,);\6
\\{fflush}(\\{stderr});\6
\4${}\}{}$\2\par
\fi

\M{43}We might also like to see the complete trail, including names and
reasons.

\Y\B\4\X31:Subroutines\X${}\mathrel+\E{}$\6
\&{void} \\{print\_trail}(\&{int} \\{eptr})\1\1\2\2\6
${}\{{}$\1\6
\&{register} \&{int} \|k${},{}$ \|l;\7
\&{for} ${}(\|k\K\T{0};{}$ ${}\|k<\\{eptr};{}$ ${}\|k\PP){}$\5
${}\{{}$\1\6
${}\|l\K\\{trail}[\|k];{}$\6
\&{if} ${}(\|k\G\\{vars}\V\|l<\T{2}\V\|l>\\{max\_lit}){}$\1\5
\&{return};\2\6
${}\\{fprintf}(\\{stderr},\39\.{""}\|O\.{"d:\ "}\|O\.{"d\ "}\|O\.{"d\ "}\|O%
\.{"s"}\|O\.{".8s("}\|O\.{"d)"},\39\|k,\39\\{history}[\|k]+(\|l\AND\T{1}),\39%
\\{vmem}[\\{thevar}(\|l)].\\{value}\GG\T{1},\39\\{litname}(\|l),\39\|l);{}$\6
\&{if} ${}(\\{lmem}[\|l].\\{reason}>\T{0}){}$\5
${}\{{}$\1\6
\&{if} ${}((\\{vmem}[\\{thevar}(\|l)].\\{value}\GG\T{1})\V\\{lmem}[\|l].%
\\{reason}<\\{min\_learned}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"\ \#"}\|O\.{"u\\n"},\39\\{lmem}[\|l].%
\\{reason});{}$\2\6
\&{else}\1\5
${}\\{fprintf}(\\{stderr},\39\.{"\ learned\\n"}){}$;\C{ learned at root level }%
\2\6
\4${}\}{}$\5
\2\&{else} \&{if} ${}(\\{lmem}[\|l].\\{reason}<\T{0}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"\ <-\ "}\|O\.{"s"}\|O\.{".8s\\n"},\39%
\\{litname}({-}\\{lmem}[\|l].\\{reason}));{}$\2\6
\&{else}\1\5
${}\\{fprintf}(\\{stderr},\39\.{"\\n"});{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{44}Here's a diagnostic routine that runs through all the nonbinary,
nonlearned clauses, printing any that are unsatisfied with respect to the
current partial assignment of values to variables.

\Y\B\4\X31:Subroutines\X${}\mathrel+\E{}$\6
\&{void} \\{print\_unsat}(\&{void})\1\1\2\2\6
${}\{{}$\1\6
\&{register} \&{int} \|c${},{}$ \\{endc}${},{}$ \|k${},{}$ \|l;\7
\&{for} ${}(\|c\K\\{clause\_extra};{}$ ${}\|c<\\{min\_learned};{}$ ${}\|c\K%
\\{endc}+\\{clause\_extra}){}$\5
${}\{{}$\1\6
${}\\{endc}\K\|c+\\{size}(\|c);{}$\6
\&{for} ${}(\|k\K\\{endc}-\T{1};{}$ ${}\|k\G\|c;{}$ ${}\|k\MM){}$\5
${}\{{}$\1\6
${}\|l\K\\{mem}[\|k].\\{lit};{}$\6
\&{if} ${}(\\{isknown}(\|l)\W\R\\{iscontrary}(\|l)){}$\1\5
\&{break};\2\6
\4${}\}{}$\2\6
\&{if} ${}(\|k<\|c){}$\5
${}\{{}$\C{ clause \PB{\|c} not satisfied }\1\6
${}\\{fprintf}(\\{stderr},\39\.{""}\|O\.{"d:"},\39\|c);{}$\6
\&{for} ${}(\|k\K\T{0};{}$ ${}\|k<\\{size}(\|c);{}$ ${}\|k\PP){}$\5
${}\{{}$\1\6
${}\|l\K\\{mem}[\|c+\|k].\\{lit};{}$\6
\&{if} ${}(\R\\{isknown}(\|l)){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"\ "}\|O\.{"s"}\|O\.{".8s"},\39\\{litname}(%
\|l));{}$\2\6
\4${}\}{}$\2\6
${}\\{fprintf}(\\{stderr},\39\.{"\ |"}){}$;\C{ the remaining literals are false
}\6
\&{for} ${}(\|k\K\T{0};{}$ ${}\|k<\\{size}(\|c);{}$ ${}\|k\PP){}$\5
${}\{{}$\1\6
${}\|l\K\\{mem}[\|c+\|k].\\{lit};{}$\6
\&{if} (\\{isknown}(\|l))\1\5
${}\\{fprintf}(\\{stderr},\39\.{"\ "}\|O\.{"s"}\|O\.{".8s"},\39\\{litname}(%
\|l));{}$\2\6
\4${}\}{}$\2\6
${}\\{fprintf}(\\{stderr},\39\.{"\\n"});{}$\6
\4${}\}{}$\2\6
\&{while} ${}(\\{mem}[\\{endc}].\\{lit}\AND\\{sign\_bit}){}$\1\5
${}\\{endc}\PP;{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\N{1}{45}Initializing the real data structures.
We're ready now to convert the temporary chunks of data into the
form we want, and to recycle those chunks. The code below is, of course,
similar to what has worked in previous programs of this series.

\Y\B\4\X45:Set up the main data structures\X${}\E{}$\6
\X46:Allocate \PB{\\{vmem}} and \PB{\\{heap}}\X;\6
\&{if} (\\{polarity\_infile})\1\5
\X79:Initialize the heap from a file\X\2\6
\&{else}\1\5
\X78:Initialize the heap randomly\X;\2\6
\X47:Allocate the other main arrays\X;\6
\X49:Copy all the temporary cells to the \PB{\\{mem}} and \PB{\\{bmem}} and %
\PB{\\{trail}} arrays in proper format\X;\6
\X54:Copy all the temporary variable nodes to the \PB{\\{vmem}} array in proper
format\X;\6
\X55:Check consistency\X;\6
\X57:Allocate the auxiliary arrays\X;\par
\U2.\fi

\M{46}\B\X46:Allocate \PB{\\{vmem}} and \PB{\\{heap}}\X${}\E{}$\6
$\\{vmem}\K{}$(\&{variable} ${}{*}){}$ \\{malloc}${}((\\{vars}+\T{1})*%
\&{sizeof}(\&{variable}));{}$\6
\&{if} ${}(\R\\{vmem}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Oops,\ I\ can't\ alloc}\)\.{ate\ the\ vmem\
array!\\}\)\.{n"});{}$\6
${}\\{exit}({-}\T{12});{}$\6
\4${}\}{}$\2\6
${}\\{bytes}\MRL{+{\K}}(\\{vars}+\T{1})*\&{sizeof}(\&{variable});{}$\6
\&{for} ${}(\|k\K\T{1};{}$ ${}\|k\Z\\{vars};{}$ ${}\|k\PP){}$\1\5
${}\|o,\39\\{vmem}[\|k].\\{value}\K\\{unset},\39\\{vmem}[\|k].\\{tloc}\K{-}%
\T{1};{}$\2\6
${}\\{heap}\K{}$(\&{uint} ${}{*}){}$ \\{malloc}${}(\\{vars}*\&{sizeof}(%
\&{uint}));{}$\6
\&{if} ${}(\R\\{heap}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Oops,\ I\ can't\ alloc}\)\.{ate\ the\ heap\
array!\\}\)\.{n"});{}$\6
${}\\{exit}({-}\T{11});{}$\6
\4${}\}{}$\2\6
${}\\{bytes}\MRL{+{\K}}\\{vars}*\&{sizeof}(\&{uint}){}$;\par
\U45.\fi

\M{47}\B\X47:Allocate the other main arrays\X${}\E{}$\6
\\{free}(\\{buf});\5
\\{free}(\\{hash});\C{ a tiny gesture to make a little room }\6
\X48:Figure out how big \PB{\\{mem}} ought to be\X;\6
${}\\{mem}\K{}$(\&{cel} ${}{*}){}$ \\{malloc}${}(\\{memsize}*\&{sizeof}(%
\&{cel}));{}$\6
\&{if} ${}(\R\\{mem}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Oops,\ I\ can't\ alloc}\)\.{ate\ the\ big\ mem%
\ arra}\)\.{y!\\n"});{}$\6
${}\\{exit}({-}\T{10});{}$\6
\4${}\}{}$\2\6
${}\\{bytes}\MRL{+{\K}}\\{max\_cells\_used}*\&{sizeof}(\&{cel});{}$\6
${}\\{max\_lit}\K\\{vars}+\\{vars}+\T{1};{}$\6
${}\\{lmem}\K{}$(\&{literal} ${}{*}){}$ \\{malloc}${}((\\{max\_lit}+\T{1})*%
\&{sizeof}(\&{literal}));{}$\6
\&{if} ${}(\R\\{lmem}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Oops,\ I\ can't\ alloc}\)\.{ate\ the\ lmem\
array!\\}\)\.{n"});{}$\6
${}\\{exit}({-}\T{13});{}$\6
\4${}\}{}$\2\6
${}\\{bytes}\MRL{+{\K}}(\\{max\_lit}+\T{1})*\&{sizeof}(\&{literal});{}$\6
${}\\{trail}\K{}$(\&{uint} ${}{*}){}$ \\{malloc}${}(\\{vars}*\&{sizeof}(%
\&{uint}));{}$\6
\&{if} ${}(\R\\{trail}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Oops,\ I\ can't\ alloc}\)\.{ate\ the\ trail\
array!}\)\.{\\n"});{}$\6
${}\\{exit}({-}\T{14});{}$\6
\4${}\}{}$\2\6
${}\\{bytes}\MRL{+{\K}}\\{vars}*\&{sizeof}(\&{uint}){}$;\par
\A56.
\U45.\fi

\M{48}The \PB{\\{mem}} array will contain $2^k-1<2^{31}$ cells of four bytes
each,
where $k$ is the parameter \PB{\\{memk\_max}}; this parameter is
\PB{\\{memk\_max\_default}} (currently~26) by default, and changeable by the
user
via \.m on the command line. (Apology: This program is for my own use in
experiments, so I haven't bothered to give it a more user-friendly interface.)

It will begin with data for all clauses of length 3 or more;
then come the learned clauses, which have slightly longer preambles.
During the initialization, some of the eventual space for learned
clauses is used temporarily to hold the binary clause information.

We will record in \PB{\\{bytes}} and \PB{\\{max\_cells\_used}} only the number
of cells actually
utilized; this at least gives the user some clue about how big \.m should be.

\Y\B\4\D$\\{memk\_max\_default}$ \5
\T{26}\C{ allow 64 million cells in \PB{\\{mem}} by default }\par
\Y\B\4\X48:Figure out how big \PB{\\{mem}} ought to be\X${}\E{}$\6
${}\{{}$\1\6
\&{ullng} \\{proto\_memsize}${}\K(\\{clauses}-\\{unaries}-\\{binaries})*%
\\{clause\_extra}+(\\{cells}-\\{unaries}-\T{2}*\\{binaries})+\\{clause%
\_extra};{}$\7
${}\\{min\_learned}\K\\{proto\_memsize};{}$\6
${}\\{proto\_memsize}\MRL{+{\K}}\T{2}*\\{binaries}+\\{learned\_supplement};{}$\6
\&{if} ${}(\\{proto\_memsize}\G\T{\^80000000}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Sorry,\ I\ can't\ hand}\)\.{le\ "}\|O\.{"llu\
cells\ (2\^31\ is\ }\)\.{my\ limit)!\\n"},\39\\{proto\_memsize});{}$\6
${}\\{exit}({-}\T{665});{}$\6
\4${}\}{}$\2\6
${}\\{max\_cells\_used}\K\\{proto\_memsize}-\\{learned\_supplement}+\T{2};{}$\6
${}\\{first\_learned}\K\\{max\_learned}\K\\{min\_learned}+\\{learned%
\_supplement};{}$\6
${}\\{memsize}\K\T{1}\LL\\{memk\_max};{}$\6
\&{if} ${}(\\{max\_cells\_used}>\\{memsize}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Immediate\ memory\ ov}\)\.{erflow\ (memsize="}%
\|O\.{"u<"}\|O\.{"u),\ please\ increase}\)\.{\ m!\\n"},\39\\{memsize},\39\\{max%
\_cells\_used});{}$\6
${}\\{exit}({-}\T{666});{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{verbose}\AND\\{show\_details}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"(learned\ clauses\ be}\)\.{gin\ at\ "}\|O%
\.{"u)\\n"},\39\\{first\_learned});{}$\2\6
\4${}\}{}$\2\par
\U47.\fi

\M{49}Binary data is copied temporarily into cells starting at \PB{$\\{min%
\_learned}+\T{2}$}.
(The `${}+2$' is needed because the final clause processed is input
with \PB{$\|c\K\\{min\_learned}$}.)

\Y\B\4\X49:Copy all the temporary cells to the \PB{\\{mem}} and \PB{\\{bmem}}
and \PB{\\{trail}} arrays in proper format\X${}\E{}$\6
$\\{eptr}\K\T{0}{}$;\C{ empty the trail in preparation for unit clauses }\6
\&{for} ${}(\|l\K\T{2};{}$ ${}\|l\Z\\{max\_lit};{}$ ${}\|l\PP){}$\1\5
${}\\{oo},\39\\{lmem}[\|l].\\{reason}\K\\{lmem}[\|l].\\{watch}\K\\{lmem}[\|l].%
\\{bimp\_end}\K\T{0};{}$\2\6
\&{for} ${}(\|c\K\\{clause\_extra},\39\|j\K\\{clauses},\39\\{jj}\K\\{min%
\_learned}+\T{2};{}$ \|j; ${}\|j\MM){}$\5
${}\{{}$\1\6
${}\|k\K\T{0};{}$\6
\X50:Insert the cells for the literals of clause \PB{\|c}\X;\6
\&{if} ${}(\|k\Z\T{2}){}$\1\5
\X51:Do special things for unary and binary clauses\X\2\6
\&{else}\5
${}\{{}$\1\6
${}\|o,\39\\{size}(\|c)\K\|k;{}$\6
${}\|l\K\\{mem}[\|c].\\{lit};{}$\6
${}\\{ooo},\39\\{link0}(\|c)\K\\{lmem}[\|l].\\{watch},\39\\{lmem}[\|l].%
\\{watch}\K\|c;{}$\6
${}\|l\K\\{mem}[\|c+\T{1}].\\{lit};{}$\6
${}\\{ooo},\39\\{link1}(\|c)\K\\{lmem}[\|l].\\{watch},\39\\{lmem}[\|l].%
\\{watch}\K\|c;{}$\6
${}\|c\MRL{+{\K}}\|k+\\{clause\_extra};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\|o,\39\\{mem}[\|c-\\{clause\_extra}].\\{lit}\K\T{0}{}$;\C{ put zero at end
of \PB{\\{mem}} }\6
\&{if} ${}(\|c\I\\{min\_learned}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Oh\ oh,\ I\ didn't\ loa}\)\.{d\ the\ correct\
number}\)\.{\ of\ cells\ ("}\|O\.{"u:"}\|O\.{"u)!\\n"},\39\|c,\39\\{min%
\_learned});{}$\6
${}\\{exit}({-}\T{17});{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{jj}\I\\{max\_cells\_used}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Oh\ oh,\ I\ miscounted}\)\.{\ binaries\
somehow\ ("}\|O\.{"u:"}\|O\.{"u)!\\n"},\39\\{jj},\39\\{max\_cells\_used});{}$\6
${}\\{exit}({-}\T{18});{}$\6
\4${}\}{}$\2\6
\X53:Reformat the binary implications\X;\par
\U45.\fi

\M{50}The basic idea is to ``unwind'' the steps that we went through while
building up the chunks.

\Y\B\4\D$\\{hack\_out}(\|q)$ \5
(((\&{ullng}) \|q)${}\AND\T{\^3}{}$)\par
\B\4\D$\\{hack\_clean}(\|q)$ \5
((\&{tmp\_var} ${}{*})({}$(\&{ullng}) \|q${}\AND{-}\T{4}){}$)\par
\Y\B\4\X50:Insert the cells for the literals of clause \PB{\|c}\X${}\E{}$\6
\&{for} ${}(\|i\K\T{0};{}$ ${}\|i<\T{2};{}$ \,)\5
${}\{{}$\1\6
\X23:Move \PB{\\{cur\_cell}} backward to the previous cell\X;\6
${}\|i\K\\{hack\_out}({*}\\{cur\_cell});{}$\6
${}\|p\K\\{hack\_clean}({*}\\{cur\_cell})\MG\\{serial};{}$\6
${}\|p\MRL{+{\K}}\|p+(\|i\AND\T{1})+\T{2};{}$\6
${}\|o,\39\\{mem}[\|c+\|k\PP].\\{lit}\K\|p;{}$\6
\4${}\}{}$\2\par
\U49.\fi

\M{51}\B\X51:Do special things for unary and binary clauses\X${}\E{}$\6
${}\{{}$\1\6
\&{if} ${}(\|k<\T{2}){}$\1\5
\X52:Define \PB{$\\{mem}[\|c].\\{lit}$} at level 0\X\2\6
\&{else}\5
${}\{{}$\1\6
${}\|l\K\\{mem}[\|c].\\{lit},\39\\{ll}\K\\{mem}[\|c+\T{1}].\\{lit}{}$;\C{ no
mem charged for these }\6
${}\\{oo},\39\\{lmem}[\\{bar}(\|l)].\\{bimp\_end}\PP;{}$\6
${}\\{oo},\39\\{lmem}[\\{bar}(\\{ll})].\\{bimp\_end}\PP;{}$\6
${}\|o,\39\\{mem}[\\{jj}].\\{lit}\K\|l,\39\\{mem}[\\{jj}+\T{1}].\\{lit}\K%
\\{ll},\39\\{jj}\MRL{+{\K}}\T{2}{}$;\C{ copy the literals temporarily }\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U49.\fi

\M{52}We have to watch for degenerate cases: Unit clauses in the input
might be duplicated or contradictory.

\Y\B\4\X52:Define \PB{$\\{mem}[\|c].\\{lit}$} at level 0\X${}\E{}$\6
${}\{{}$\1\6
${}\|l\K\\{mem}[\|c].\\{lit},\39\|v\K\\{thevar}(\|l);{}$\6
\&{if} ${}(\|o,\39\\{vmem}[\|v].\\{value}\E\\{unset}){}$\5
${}\{{}$\1\6
${}\|o,\39\\{vmem}[\|v].\\{value}\K\|l\AND\T{1},\39\\{vmem}[\|v].\\{tloc}\K%
\\{eptr};{}$\6
${}\|o,\39\\{history}[\\{eptr}]\K\T{6},\39\\{trail}[\\{eptr}\PP]\K\|l;{}$\6
\4${}\}{}$\5
\2\&{else} \&{if} ${}(\\{vmem}[\|v].\\{value}\I(\|l\AND\T{1})){}$\1\5
\&{goto} \\{unsat};\2\6
\4${}\}{}$\2\par
\U51.\fi

\M{53}\B\X53:Reformat the binary implications\X${}\E{}$\6
\&{for} ${}(\|l\K\T{2},\39\\{jj}\K\T{0};{}$ ${}\|l\Z\\{max\_lit};{}$ ${}\|l%
\PP){}$\5
${}\{{}$\1\6
${}\|o,\39\|k\K\\{lmem}[\|l].\\{bimp\_end};{}$\6
\&{if} (\|k)\1\5
${}\|o,\39\\{lmem}[\|l].\\{bimp\_start}\K\\{lmem}[\|l].\\{bimp\_end}\K\\{jj},%
\39\\{jj}\MRL{+{\K}}\|k;{}$\2\6
\4${}\}{}$\2\6
\&{for} ${}(\\{jj}\K\\{min\_learned}+\T{2},\39\|j\K\\{binaries};{}$ \|j; ${}\|j%
\MM){}$\5
${}\{{}$\1\6
${}\|o,\39\|l\K\\{mem}[\\{jj}].\\{lit},\39\\{ll}\K\\{mem}[\\{jj}+\T{1}].%
\\{lit},\39\\{jj}\MRL{+{\K}}\T{2};{}$\6
${}\\{ooo},\39\|k\K\\{lmem}[\\{bar}(\|l)].\\{bimp\_end},\39\\{bmem}[\|k]\K%
\\{ll},\39\\{lmem}[\\{bar}(\|l)].\\{bimp\_end}\K\|k+\T{1};{}$\6
${}\\{ooo},\39\|k\K\\{lmem}[\\{bar}(\\{ll})].\\{bimp\_end},\39\\{bmem}[\|k]\K%
\|l,\39\\{lmem}[\\{bar}(\\{ll})].\\{bimp\_end}\K\|k+\T{1};{}$\6
\4${}\}{}$\2\par
\U49.\fi

\M{54}\B\X54:Copy all the temporary variable nodes to the \PB{\\{vmem}} array
in proper format\X${}\E{}$\6
\&{for} ${}(\|c\K\\{vars};{}$ \|c; ${}\|c\MM){}$\5
${}\{{}$\1\6
\X24:Move \PB{\\{cur\_tmp\_var}} backward to the previous temporary variable\X;%
\6
${}\|o,\39\\{vmem}[\|c].\\{name}.\\{lng}\K\\{cur\_tmp\_var}\MG\\{name}.%
\\{lng};{}$\6
${}\|o,\39\\{vmem}[\|c].\\{stamp}\K\T{0};{}$\6
\4${}\}{}$\2\par
\U45.\fi

\M{55}We should now have unwound all the temporary data chunks back to their
beginnings.

\Y\B\4\X55:Check consistency\X${}\E{}$\6
\&{if} ${}(\\{cur\_cell}\I{\AND}\\{cur\_chunk}\MG\\{cell}[\T{0}]\V\\{cur%
\_chunk}\MG\\{prev}\I\NULL\V\\{cur\_tmp\_var}\I{\AND}\\{cur\_vchunk}\MG\\{var}[%
\T{0}]\V\\{cur\_vchunk}\MG\\{prev}\I\NULL){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"This\ can't\ happen\ (}\)\.{consistency\ check%
\ fa}\)\.{ilure)!\\n"});{}$\6
${}\\{exit}({-}\T{14});{}$\6
\4${}\}{}$\2\6
\\{free}(\\{cur\_chunk});\5
\\{free}(\\{cur\_vchunk});\par
\U45.\fi

\M{56}A few arrays aren't really of ``main'' importance, but we need to
allocate
them before incorporating the clause information into \PB{\\{mem}}.

\Y\B\4\X47:Allocate the other main arrays\X${}\mathrel+\E{}$\6
$\\{bmem}\K{}$(\&{uint} ${}{*}){}$ \\{malloc}${}(\\{binaries}*\T{2}*\&{sizeof}(%
\&{uint}));{}$\6
\&{if} ${}(\R\\{bmem}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Oops,\ I\ can't\ alloc}\)\.{ate\ the\ bmem\
array!\\}\)\.{n"});{}$\6
${}\\{exit}({-}\T{16});{}$\6
\4${}\}{}$\2\6
${}\\{bytes}\MRL{+{\K}}\\{binaries}*\T{2}*\&{sizeof}(\&{uint});{}$\6
${}\\{history}\K{}$(\&{char} ${}{*}){}$ \\{malloc}${}(\\{vars}*\&{sizeof}(%
\&{char}));{}$\6
\&{if} ${}(\R\\{history}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Oops,\ I\ can't\ alloc}\)\.{ate\ the\ history\
arra}\)\.{y!\\n"});{}$\6
${}\\{exit}({-}\T{15});{}$\6
\4${}\}{}$\2\6
${}\\{bytes}\MRL{+{\K}}\\{vars}*\&{sizeof}(\&{char}){}$;\par
\fi

\M{57}The other arrays can perhaps make use of the memory chunks that are
freed while we're reformatting the clause and variable data.

\Y\B\4\X57:Allocate the auxiliary arrays\X${}\E{}$\6
$\\{leveldat}\K{}$(\&{int} ${}{*}){}$ \\{malloc}${}(\\{vars}*\T{2}*\&{sizeof}(%
\&{int}));{}$\6
\&{if} ${}(\R\\{leveldat}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Oops,\ I\ can't\ alloc}\)\.{ate\ the\ leveldat%
\ arr}\)\.{ay!\\n"});{}$\6
${}\\{exit}({-}\T{16});{}$\6
\4${}\}{}$\2\6
${}\\{bytes}\MRL{+{\K}}\\{vars}*\T{2}*\&{sizeof}(\&{int}){}$;\par
\As89, 96, 109\ETs116.
\U45.\fi

\N{1}{58}Forcing. This program spends most of its time adding literals
to the current trail when they are forced to be true because of
earlier items on the trail.

The ``inner loop'' of the forcing phase tries to derive the
consequences of literal~\PB{\|l} that follow from binary clauses in the
input. At this point \PB{\|l} is a literal in the trail.
Furthermore \PB{$\\{lat}\K\\{lmem}[\|l].\\{bimp\_end}$}
has just been fetched, and it's known to be nonzero.

(I apologize for the awkward interface between this loop and its context.
Maybe I shouldn't worry so much about saving mems in the inner loop.
But that's the kind of guy I~am.)

\Y\B\4\X58:Propagate binary implications of \PB{\|l}; \PB{\&{goto} \\{confl}}
if a conflict arises\X${}\E{}$\6
\&{for} ${}(\\{lbptr}\K\\{eptr};{}$  ; \,)\5
${}\{{}$\1\6
\&{for} ${}(\\{la}\K\\{lmem}[\|l].\\{bimp\_start};{}$ ${}\\{la}<\\{lat};{}$ ${}%
\\{la}\PP){}$\5
${}\{{}$\1\6
${}\|o,\39\\{ll}\K\\{bmem}[\\{la}];{}$\6
\&{if} ${}(\|o,\39\\{isknown}(\\{ll})){}$\5
${}\{{}$\1\6
\&{if} (\\{iscontrary}(\\{ll}))\5
${}\{{}$\1\6
${}\\{props}\PP;{}$\6
\X66:Deal with a binary conflict\X;\6
\4${}\}{}$\2\6
\4${}\}{}$\5
\2\&{else}\5
${}\{{}$\1\6
${}\\{props}\PP;{}$\6
\&{if} ${}(\\{verbose}\AND\\{show\_details}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"\ "}\|O\.{"s"}\|O\.{".8s\ ->\ "}\|O\.{"s"}\|O%
\.{".8s\\n"},\39\\{litname}(\|l),\39\\{litname}(\\{ll}));{}$\2\6
${}\|o,\39\\{history}[\\{eptr}]\K\T{4},\39\\{trail}[\\{eptr}]\K\\{ll};{}$\6
${}\|o,\39\\{lmem}[\\{ll}].\\{reason}\K{-}\|l;{}$\6
${}\|o,\39\\{vmem}[\\{thevar}(\\{ll})].\\{value}\K\\{llevel}+(\\{ll}\AND\T{1}),%
\39\\{vmem}[\\{thevar}(\\{ll})].\\{tloc}\K\\{eptr}\PP;{}$\6
${}\\{agility}\MRL{-{\K}}\\{agility}\GG\T{13}{}$;\C{ use the damping factor
$1-2^{-13}$ }\6
\&{if} ${}(\|o,\39(\\{vmem}[\\{thevar}(\\{ll})].\\{oldval}+\\{ll})\AND\T{1}){}$%
\1\5
${}\\{agility}\MRL{+{\K}}\T{1}\LL\T{19};{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{while} (\T{1})\5
${}\{{}$\1\6
\&{if} ${}(\\{lbptr}\E\\{eptr}){}$\5
${}\{{}$\1\6
${}\|l\K\T{0}{}$;\5
\&{break};\C{ kludge for breaking out of two loops }\6
\4${}\}{}$\2\6
${}\|o,\39\|l\K\\{trail}[\\{lbptr}\PP];{}$\6
${}\|o,\39\\{lat}\K\\{lmem}[\|l].\\{bimp\_end};{}$\6
\&{if} (\\{lat})\1\5
\&{break};\2\6
\4${}\}{}$\2\6
\&{if} ${}(\|l\E\T{0}){}$\1\5
\&{break};\2\6
\4${}\}{}$\2\par
\Us65\ET127.\fi

\M{59}\B\X4:Global variables\X${}\mathrel+\E{}$\6
\&{uint} \\{lt};\C{ literal on the trail }\6
\&{uint} \\{lat};\C{ its \PB{\\{bimp\_end}} }\6
\&{uint} \\{wa}${},{}$ \\{next\_wa};\C{ a clause in its watch list }\par
\fi

\M{60}The ``next to inner loop'' of forcing looks for nonbinary
clauses that have at most one literal that isn't false.

At this point we're looking at a literal \PB{\\{lt}} that was placed on the
trail.
Its binary implications were found at that time; now we want to examine
the more complex ones, by looking at all clauses on the watch
list of \PB{\\{bar}(\\{lt})}.

While doing this, we swap the first two literals, if necessary, so that
\PB{\\{bar}(\\{lt})} is the second one watching.

Counting of mems is a bit tricky here: If \PB{\|c} is the address of a clause,
either \PB{$\\{mem}[\|c].\\{lit}$} and \PB{$\\{mem}[\|c+\T{1}].\\{lit}$} are in
the same octabyte,
or \PB{\\{link0}(\|c)} and \PB{\\{link1}(\|c)}, but not both. So we make three
memory
references when we're reading from or storing into all four items.

\Y\B\4\X60:Propagate nonbinary implications of \PB{\\{lt}}; \PB{\&{goto} %
\\{confl}} if there's a conflict\X${}\E{}$\6
$\|o,\39\\{wa}\K\\{lmem}[\\{bar}(\\{lt})].\\{watch};{}$\6
\&{if} (\\{wa})\5
${}\{{}$\1\6
\&{for} ${}(\|q\K\T{0};{}$ \\{wa}; ${}\\{wa}\K\\{next\_wa}){}$\5
${}\{{}$\1\6
${}\|o,\39\\{ll}\K\\{mem}[\\{wa}].\\{lit};{}$\6
\&{if} ${}(\\{ll}\E\\{bar}(\\{lt})){}$\5
${}\{{}$\1\6
${}\|o,\39\\{ll}\K\\{mem}[\\{wa}+\T{1}].\\{lit};{}$\6
${}\\{oo},\39\\{mem}[\\{wa}].\\{lit}\K\\{ll},\39\\{mem}[\\{wa}+\T{1}].\\{lit}\K%
\\{bar}(\\{lt});{}$\6
${}\|o,\39\\{next\_wa}\K\\{link0}(\\{wa});{}$\6
${}\|o,\39\\{link0}(\\{wa})\K\\{link1}(\\{wa}),\39\\{link1}(\\{wa})\K\\{next%
\_wa};{}$\6
\4${}\}{}$\5
\2\&{else}\1\5
${}\|o,\39\\{next\_wa}\K\\{link1}(\\{wa});{}$\2\6
\X63:If clause \PB{\\{wa}} is satisfied by \PB{\\{ll}}, keep \PB{\\{wa}} on the
watch list and \PB{\&{continue}}\X;\6
\&{for} ${}(\|o,\39\|s\K\\{size}(\\{wa}),\39\|j\K\\{wa}+\|s-\T{1};{}$ ${}\|j>%
\\{wa}+\T{1};{}$ ${}\|j\MM){}$\5
${}\{{}$\1\6
${}\|o,\39\|l\K\\{mem}[\|j].\\{lit};{}$\6
\&{if} ${}(\|o,\39\R\\{isknown}(\|l)\V\R\\{iscontrary}(\|l)){}$\1\5
\&{break};\2\6
\&{if} ${}(\\{vmem}[\\{thevar}(\|l)].\\{value}<\T{2}\W\\{llevel}){}$\1\5
\X61:Delete \PB{\|l} from clause \PB{\\{wa}}\X;\2\6
\4${}\}{}$\2\6
\&{if} ${}(\|j>\\{wa}+\T{1}){}$\1\5
\X62:Swap \PB{\\{wa}} to the watch list of \PB{\|l} and \PB{\&{continue}}\X;\2\6
\X64:Keep \PB{\\{wa}} on the watch list\X;\6
\X65:Force a new value, if appropriate, or \PB{\&{goto} \\{confl}}\X;\6
\4${}\}{}$\2\6
\X64:Keep \PB{\\{wa}} on the watch list\X;\C{ this terminates the watch list
with 0 }\6
\4${}\}{}$\2\par
\U127.\fi

\M{61}The literal \PB{\|l} is known to be permanently false, so we seize this
opportunity to remove it from the active memory. (Such deletions will
be important later, when we attempt to do ``on-the-fly subsumption.'')

At this point, \PB{\|s} is the current size of clause \PB{\\{wa}}.

\Y\B\4\X61:Delete \PB{\|l} from clause \PB{\\{wa}}\X${}\E{}$\6
${}\{{}$\1\6
${}\|o,\39\\{size}(\\{wa})\K\MM\|s;{}$\6
\&{if} ${}(\|j\I\\{wa}+\|s){}$\1\5
${}\\{oo},\39\\{mem}[\|j].\\{lit}\K\\{mem}[\\{wa}+\|s].\\{lit}{}$;\C{ swap past
end of clause }\2\6
${}\|o,\39\\{mem}[\\{wa}+\|s].\\{lit}\K\|l+\\{sign\_bit};{}$\6
\4${}\}{}$\2\par
\U60.\fi

\M{62}\B\X62:Swap \PB{\\{wa}} to the watch list of \PB{\|l} and \PB{%
\&{continue}}\X${}\E{}$\6
${}\{{}$\1\6
\&{if} ${}(\\{verbose}\AND\\{show\_watches}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"\ "}\|O\.{"s"}\|O\.{".8s\ watched\ in\ "}\|O%
\.{"d\\n"},\39\\{litname}(\|l),\39\\{wa});{}$\2\6
${}\\{oo},\39\\{mem}[\\{wa}+\T{1}].\\{lit}\K\|l,\39\\{mem}[\|j].\\{lit}\K%
\\{bar}(\\{lt});{}$\6
${}\|o,\39\\{link1}(\\{wa})\K\\{lmem}[\|l].\\{watch};{}$\6
${}\|o,\39\\{lmem}[\|l].\\{watch}\K\\{wa};{}$\6
\&{continue};\6
\4${}\}{}$\2\par
\U60.\fi

\M{63}We're looking at clause \PB{\\{wa}}, which is watched by \PB{\\{bar}(%
\\{lt})} and \PB{\\{ll}},
where \PB{\\{lt}} is known to be true (at least with respect to the
decisions currently in force).

Consider what happens in the case that literal \PB{\\{ll}} is also true,
thereby satisfying clause~\PB{\\{wa}}: We can continue with \PB{\\{wa}} on the
watch list of \PB{\\{bar}(\\{lt})}, even though \PB{\\{bar}(\\{lt})} is false,
because this
clause will remain satisfied until backtracking makes \PB{\\{lt}} undefined.

\Y\B\4\X63:If clause \PB{\\{wa}} is satisfied by \PB{\\{ll}}, keep \PB{\\{wa}}
on the watch list and \PB{\&{continue}}\X${}\E{}$\6
\&{if} ${}((\|o,\39\\{isknown}(\\{ll}))\W\R\\{iscontrary}(\\{ll})){}$\5
${}\{{}$\1\6
\X64:Keep \PB{\\{wa}} on the watch list\X;\6
\&{continue};\6
\4${}\}{}$\2\par
\U60.\fi

\M{64}A satisfied clause \PB{\\{wa}} can be watched by a false literal, as
noted above.
Furthermore, during full runs we allow clauses to become entirely false;
in such cases both watchers must have become false
on the maximum level of all literals in~\PB{\\{wa}}.

\Y\B\4\X64:Keep \PB{\\{wa}} on the watch list\X${}\E{}$\6
\&{if} ${}(\|q\E\T{0}){}$\1\5
${}\|o,\39\\{lmem}[\\{bar}(\\{lt})].\\{watch}\K\\{wa};{}$\2\6
\&{else}\1\5
${}\|o,\39\\{link1}(\|q)\K\\{wa};{}$\2\6
${}\|q\K\\{wa}{}$;\par
\Us60\ET63.\fi

\M{65}Well, all literals of clause \PB{\\{wa}}, except possibly the first one,
did in fact turn out to be false. That first literal is what the
program calls~\PB{\\{ll}}, and we've already verified that \PB{\\{ll}} isn't
true.

If \PB{\\{ll}} is false, we've run into a conflict.
Otherwise we will force \PB{\\{ll}} to be true at the current decision level.

\Y\B\4\X65:Force a new value, if appropriate, or \PB{\&{goto} \\{confl}}\X${}%
\E{}$\6
$\\{props}\PP;{}$\6
\&{if} (\\{isknown}(\\{ll}))\1\5
\X67:Deal with a nonbinary conflict\X\2\6
\&{else}\5
${}\{{}$\1\6
\&{if} ${}(\\{verbose}\AND\\{show\_details}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"\ "}\|O\.{"s"}\|O\.{".8s\ from\ "}\|O\.{"d%
\\n"},\39\\{litname}(\\{ll}),\39\\{wa});{}$\2\6
${}\|o,\39\\{history}[\\{eptr}]\K\T{4},\39\\{trail}[\\{eptr}]\K\\{ll};{}$\6
${}\|o,\39\\{vmem}[\\{thevar}(\\{ll})].\\{tloc}\K\\{eptr}\PP;{}$\6
${}\\{vmem}[\\{thevar}(\\{ll})].\\{value}\K\\{llevel}+(\\{ll}\AND\T{1});{}$\6
${}\\{agility}\MRL{-{\K}}\\{agility}\GG\T{13}{}$;\C{ use the damping factor
$1-2^{-13}$ }\6
\&{if} ${}(\|o,\39(\\{vmem}[\\{thevar}(\\{ll})].\\{oldval}+\\{ll})\AND\T{1}){}$%
\1\5
${}\\{agility}\MRL{+{\K}}\T{1}\LL\T{19};{}$\2\6
${}\|o,\39\\{lmem}[\\{ll}].\\{reason}\K\\{wa};{}$\6
${}\|o,\39\\{lat}\K\\{lmem}[\\{ll}].\\{bimp\_end};{}$\6
\&{if} (\\{lat})\5
${}\{{}$\1\6
${}\|l\K\\{ll};{}$\6
\X58:Propagate binary implications of \PB{\|l}; \PB{\&{goto} \\{confl}} if a
conflict arises\X;\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U60.\fi

\M{66}In the case considered here, a conflict has arisen from the binary clause
$\bar u\lor\bar v$, where $u=l$ and $\bar v=\hbox{\PB{\\{ll}}}$.
This clause is represented
only implicitly in the \PB{\\{bmem}} array, not explicitly in~\PB{\\{mem}}.

\Y\B\4\X66:Deal with a binary conflict\X${}\E{}$\6
${}\{{}$\1\6
\&{if} ${}(\\{verbose}\AND\\{show\_details}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"\ "}\|O\.{"s"}\|O\.{".8s\ ->\ "}\|O\.{"s"}\|O%
\.{".8s\ \#\\n"},\39\\{litname}(\|l),\39\\{litname}(\\{ll}));{}$\2\6
\&{if} ${}(\\{full\_run}\W\\{llevel}){}$\1\5
\X68:Record a binary conflict\X\2\6
\&{else}\5
${}\{{}$\1\6
${}\|c\K{-}\|l;{}$\6
\&{goto} \\{confl};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U58.\fi

\M{67}\B\X67:Deal with a nonbinary conflict\X${}\E{}$\6
${}\{{}$\1\6
\&{if} ${}(\\{verbose}\AND\\{show\_details}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"\ "}\|O\.{"s"}\|O\.{".8s\ from\ "}\|O\.{"d\ \#%
\\n"},\39\\{litname}(\\{ll}),\39\\{wa});{}$\2\6
\&{if} ${}(\\{full\_run}\W\\{llevel}){}$\1\5
\X69:Record a nonbinary conflict\X\2\6
\&{else}\5
${}\{{}$\1\6
${}\|c\K\\{wa};{}$\6
\&{goto} \\{confl};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U65.\fi

\M{68}During a ``full run,'' we continue to propagate after finding a conflict.
We remember only the first one, at any given level,
putting its clause number into \PB{$\\{leveldat}[\\{llevel}+\T{1}]$}.

The ``clause number'' of a binary clause is
considered to be \PB{${-}\|l$}, and the value of \PB{\\{bar}(\\{ll})} is saved
in odd-numbered entries of the \PB{\\{conflictdat}} array.

A stack of levels on which conflicts have occurred is maintained
in the even-numbered entries of \PB{\\{conflictdat}}. The top of this
stack is called \PB{\\{conflict\_level}}.

\Y\B\4\X68:Record a binary conflict\X${}\E{}$\6
${}\{{}$\1\6
\&{if} ${}(\R\\{conflict\_seen}){}$\5
${}\{{}$\1\6
${}\\{conflict\_seen}\K\T{1};{}$\6
${}\|o,\39\\{leveldat}[\\{llevel}+\T{1}]\K{-}\|l;{}$\6
${}\|o,\39\\{conflictdat}[\\{llevel}+\T{1}]\K\\{ll};{}$\6
${}\\{conflictdat}[\\{llevel}]\K\\{conflict\_level},\39\\{conflict\_level}\K%
\\{llevel};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U66.\fi

\M{69}\B\X69:Record a nonbinary conflict\X${}\E{}$\6
${}\{{}$\1\6
\&{if} ${}(\R\\{conflict\_seen}){}$\5
${}\{{}$\1\6
${}\\{conflict\_seen}\K\T{1};{}$\6
${}\|o,\39\\{leveldat}[\\{llevel}+\T{1}]\K\\{wa};{}$\6
${}\|o,\39\\{conflictdat}[\\{llevel}]\K\\{conflict\_level},\39\\{conflict%
\_level}\K\\{llevel};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U67.\fi

\N{1}{70}Activity scores.
Experience shows that it's usually a good idea to branch on a variable that
has participated recently in the construction of conflict clauses. More
precisely, we try to maximize ``activity,'' where the activity of variable~$v$
is proportional to the sum of $\{\rho^t\mid v$ participates in the
$t\,$th-from-last conflict$\}$; here $\rho$ is a parameter representing
the rate of decay by which influential activity decays with time.
(Users can change the default ratio $\rho=.95$ if desired.)

There's a simple way to implement this quantity, because activity is
also proportional to the sum of $\{\rho^{-t}\mid v$ participates in the
$t\,$th conflict$\}$; that sum counts forward in time rather than backward.
We can therefore get proper results by adding \PB{\\{var\_bump}} to $v$'s score
whenever $v$ participates in a conflict, and then dividing \PB{\\{var\_bump}}
by~$\rho$ after each conflict.

If the activity scores computed in this way become too large, we simply
scale them back, so that relative ratios are preserved.

Incidentally, the somewhat mysterious acronym {\mc VSIDS}, which
stands for ``variable state independent decaying sum,'' is often
used by insiders to describe this aspect of a CDCL solver. The
activity scoring mechanism adopted here, due to Niklas E\'en
in the 2005 version of MiniSAT, was inspired by a
similar but less effective {\mc VSIDS} scheme originally introduced
by Matthew Moskewitz in the {\mc CHAFF} solver.

\Y\B\4\X70:Bump \PB{\|l}'s activity\X${}\E{}$\6
$\|v\K\\{thevar}(\|l);{}$\6
${}\|o,\39\\{av}\K\\{vmem}[\|v].\\{activity}+\\{var\_bump};{}$\6
${}\|o,\39\\{vmem}[\|v].\\{activity}\K\\{av};{}$\6
\&{if} ${}(\\{av}\G\T{1\_100}){}$\1\5
\X83:Rescale all variable activities\X;\2\6
${}\|o,\39\|h\K\\{vmem}[\|v].\\{hloc};{}$\6
\&{if} ${}(\|h>\T{0}){}$\1\5
\X73:Sift \PB{\|v} up in the heap\X;\2\par
\Us87, 88\ETs95.\fi

\M{71}The heap contains \PB{\\{hn}} variables, ordered in such a way that
\PB{$\\{vmem}[\|x].\\{activity}\G\\{vmem}[\|y].\\{activity}$} whenever \PB{$\|x%
\K\\{heap}[\|h]$} and
\PB{$\|y\K\\{heap}[\T{2}*\|h+\T{1}]$} or \PB{$\|y\K\\{heap}[\T{2}*\|h+\T{2}]$}.
In particular, \PB{\\{heap}[\T{0}]} always
names a variable of maximum activity.

\Y\B\4\X31:Subroutines\X${}\mathrel+\E{}$\6
\&{void} \\{print\_heap}(\&{void})\1\1\2\2\6
${}\{{}$\1\6
\&{register} \&{int} \|k;\7
\&{for} ${}(\|k\K\T{0};{}$ ${}\|k<\\{hn};{}$ ${}\|k\PP){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{""}\|O\.{"d:\ "}\|O\.{".8s\ "}\|O\.{"e\\n"},\39%
\|k,\39\\{vmem}[\\{heap}[\|k]].\\{name}.\\{ch8},\39\\{vmem}[\\{heap}[\|k]].%
\\{activity});{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{72}\B\X72:Check the sanity of the heap\X${}\E{}$\6
\&{for} ${}(\|k\K\T{1};{}$ ${}\|k\Z\\{vars};{}$ ${}\|k\PP){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{vmem}[\|k].\\{hloc}\G\\{hn}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"hloc\ of\ "}\|O\.{".8s\ exceeds\ "}\|O\.{"d!%
\\n"},\39\\{vmem}[\|k].\\{name}.\\{ch8},\39\\{hn}-\T{1});{}$\2\6
\&{else} \&{if} ${}(\\{vmem}[\|k].\\{hloc}\G\T{0}\W\\{heap}[\\{vmem}[\|k].%
\\{hloc}]\I\|k){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"hloc\ of\ "}\|O\.{".8s\ errs!\\n"},\39%
\\{vmem}[\|k].\\{name}.\\{ch8});{}$\2\6
\4${}\}{}$\2\6
\&{for} ${}(\|k\K\T{0};{}$ ${}\|k<\\{hn};{}$ ${}\|k\PP){}$\5
${}\{{}$\1\6
${}\|v\K\\{heap}[\|k];{}$\6
\&{if} ${}(\|v\Z\T{0}\V\|v>\\{vars}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"heap["}\|O\.{"d]="}\|O\.{"d!\\n"},\39\|k,\39%
\|v);{}$\2\6
\&{else} \&{if} (\|k)\5
${}\{{}$\1\6
${}\|u\K\\{heap}[(\|k-\T{1})\GG\T{1}];{}$\6
\&{if} ${}(\|u>\T{0}\W\|u\Z\\{vars}\W\\{vmem}[\|u].\\{activity}<\\{vmem}[\|v].%
\\{activity}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"heap["}\|O\.{"d]act<heap["}\|O\.{"d]act!\\n"},%
\39(\|k-\T{1})\GG\T{1},\39\|k);{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U34.\fi

\M{73}At this point we assume that \PB{$\\{av}\K\\{vmem}[\|v].\\{activity}$}.

\Y\B\4\X73:Sift \PB{\|v} up in the heap\X${}\E{}$\6
${}\{{}$\1\6
${}\\{hp}\K(\|h-\T{1})\GG\T{1}{}$;\C{ the ``parent'' of position \PB{\|h} }\6
${}\|o,\39\|u\K\\{heap}[\\{hp}];{}$\6
\&{if} ${}(\|o,\39\\{vmem}[\|u].\\{activity}<\\{av}){}$\5
${}\{{}$\1\6
\&{while} (\T{1})\5
${}\{{}$\1\6
${}\|o,\39\\{heap}[\|h]\K\|u;{}$\6
${}\|o,\39\\{vmem}[\|u].\\{hloc}\K\|h;{}$\6
${}\|h\K\\{hp};{}$\6
\&{if} ${}(\|h\E\T{0}){}$\1\5
\&{break};\2\6
${}\\{hp}\K(\|h-\T{1})\GG\T{1};{}$\6
${}\|o,\39\|u\K\\{heap}[\\{hp}];{}$\6
\&{if} ${}(\|o,\39\\{vmem}[\|u].\\{activity}\G\\{av}){}$\1\5
\&{break};\2\6
\4${}\}{}$\2\6
${}\|o,\39\\{heap}[\|h]\K\|v;{}$\6
${}\|o,\39\\{vmem}[\|v].\\{hloc}\K\|h;{}$\6
${}\|j\K\T{1};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\Us70\ET74.\fi

\M{74}\B\X74:Put \PB{\|v} into the heap\X${}\E{}$\6
${}\{{}$\1\6
${}\|o,\39\\{av}\K\\{vmem}[\|v].\\{activity};{}$\6
${}\|h\K\\{hn}\PP,\39\|j\K\T{0};{}$\6
\&{if} ${}(\|h>\T{0}){}$\1\5
\X73:Sift \PB{\|v} up in the heap\X;\2\6
\&{if} ${}(\|j\E\T{0}){}$\1\5
${}\\{oo},\39\\{heap}[\|h]\K\|v,\39\\{vmem}[\|v].\\{hloc}\K\|h;{}$\2\6
\4${}\}{}$\2\par
\U128.\fi

\M{75}With probability \PB{\\{rand\_prob}}, we select a variable from the heap
at random;
this policy is a heuristic designed to avoid getting into a rut.
Otherwise we take the variable at the top, because that variable has
maximum activity.

Variables in the heap often have known values, however. If our
first choice was one of them, we keep trying from the top,
until we find \PB{$\\{vmem}[\|v].\\{value}\E\\{unset}$}.

The variable's polarity is taken from \PB{$\\{vmem}[\|v].\\{oldval}$}, because
good values from prior experiments tend to remain good.

As in other programs of this family, the cost of generating
31 random bits is four mems.

\Y\B\4\D$\\{two\_to\_the\_31}$ \5
((\&{unsigned} \&{long}) \T{\^80000000})\par
\Y\B\4\X75:Choose the next decision literal, \PB{\|l}\X${}\E{}$\6
\&{if} (\\{rand\_prob\_thresh})\5
${}\{{}$\1\6
${}\\{mems}\MRL{+{\K}}\T{4},\39\|h\K\\{gb\_next\_rand}(\,);{}$\6
\&{if} ${}(\|h<\\{rand\_prob\_thresh}){}$\5
${}\{{}$\1\6
\X76:Set \PB{\|h} to a random integer less than \PB{\\{hn}}\X\6
${}\|o,\39\|v\K\\{heap}[\|h];{}$\6
\&{if} ${}(\|o,\39\\{vmem}[\|v].\\{value}\I\\{unset}){}$\1\5
${}\|h\K\T{0};{}$\2\6
\4${}\}{}$\5
\2\&{else}\1\5
${}\|h\K\T{0};{}$\2\6
\4${}\}{}$\5
\2\&{else}\1\5
${}\|h\K\T{0};{}$\2\6
\&{if} ${}(\|h\E\T{0}){}$\5
${}\{{}$\1\6
\&{while} (\T{1})\5
${}\{{}$\1\6
${}\|o,\39\|v\K\\{heap}[\T{0}];{}$\6
\X77:Delete \PB{\|v} from the heap\X;\6
\&{if} ${}(\|o,\39\\{vmem}[\|v].\\{value}\E\\{unset}){}$\1\5
\&{break};\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\|o,\39\|l\K\\{poslit}(\|v)+(\\{vmem}[\|v].\\{oldval}\AND\T{1}){}$;\par
\U124.\fi

\M{76}\B\X76:Set \PB{\|h} to a random integer less than \PB{\\{hn}}\X${}\E{}$\6
${}\{{}$\1\6
\&{register} \&{unsigned} \&{long} \|t${}\K\\{two\_to\_the\_31}-(\\{two\_to%
\_the\_31}\Xmod\\{hn});{}$\6
\&{register} \&{long} \|r;\7
\&{do}\5
${}\{{}$\1\6
${}\\{mems}\MRL{+{\K}}\T{4},\39\|r\K\\{gb\_next\_rand}(\,);{}$\6
\4${}\}{}$\5
\2\5
\&{while} ${}(\|t\Z{}$(\&{unsigned} \&{long}) \|r);\6
${}\|h\K\|r\Xmod\\{hn};{}$\6
\4${}\}{}$\2\par
\Us75\ET78.\fi

\M{77}Here we assume that \PB{$\|v\K\\{heap}[\T{0}]$}.

\Y\B\4\X77:Delete \PB{\|v} from the heap\X${}\E{}$\6
$\|o,\39\\{vmem}[\|v].\\{hloc}\K{-}\T{1};{}$\6
\&{if} ${}(\MM\\{hn}){}$\5
${}\{{}$\1\6
${}\|o,\39\|u\K\\{heap}[\\{hn}]{}$;\C{ we'll move \PB{\|u} into the ``hole'' at
position 0 }\6
${}\|o,\39\\{au}\K\\{vmem}[\|u].\\{activity};{}$\6
\&{for} ${}(\|h\K\T{0},\39\\{hp}\K\T{1};{}$ ${}\\{hp}<\\{hn};{}$ ${}\|h\K%
\\{hp},\39\\{hp}\K\|h+\|h+\T{1}){}$\5
${}\{{}$\1\6
${}\\{oo},\39\\{av}\K\\{vmem}[\\{heap}[\\{hp}]].\\{activity};{}$\6
\&{if} ${}(\\{hp}+\T{1}<\\{hn}\W(\\{oo},\39\\{vmem}[\\{heap}[\\{hp}+\T{1}]].%
\\{activity}>\\{av})){}$\1\5
${}\\{hp}\PP,\39\\{av}\K\\{vmem}[\\{heap}[\\{hp}]].\\{activity};{}$\2\6
\&{if} ${}(\\{au}\G\\{av}){}$\1\5
\&{break};\2\6
${}\|o,\39\\{heap}[\|h]\K\\{heap}[\\{hp}];{}$\6
${}\|o,\39\\{vmem}[\\{heap}[\\{hp}]].\\{hloc}\K\|h;{}$\6
\4${}\}{}$\2\6
${}\|o,\39\\{heap}[\|h]\K\|u;{}$\6
${}\|o,\39\\{vmem}[\|u].\\{hloc}\K\|h;{}$\6
\4${}\}{}$\2\par
\Us75\ET137.\fi

\M{78}At the very beginning, all activity scores are zero.
We'll permute the variables randomly in \PB{\\{heap}}, for the sake of variety.

\Y\B\4\X78:Initialize the heap randomly\X${}\E{}$\6
${}\{{}$\1\6
\&{if} ${}(\\{true\_prob}\G\T{1.0}){}$\1\5
${}\\{true\_prob\_thresh}\K\T{\^80000000};{}$\2\6
\&{else}\1\5
${}\\{true\_prob\_thresh}\K(\&{int})(\\{true\_prob}*\T{2147483648.0});{}$\2\6
\&{for} ${}(\|k\K\T{1};{}$ ${}\|k\Z\\{vars};{}$ ${}\|k\PP){}$\1\5
${}\|o,\39\\{heap}[\|k-\T{1}]\K\|k;{}$\2\6
\&{for} ${}(\\{hn}\K\\{vars};{}$ ${}\\{hn}>\T{1};{}$ \,)\5
${}\{{}$\1\6
\X76:Set \PB{\|h} to a random integer less than \PB{\\{hn}}\X;\6
${}\\{hn}\MM;{}$\6
\&{if} ${}(\|h\I\\{hn}){}$\5
${}\{{}$\1\6
${}\|o,\39\|k\K\\{heap}[\|h];{}$\6
${}\\{ooo},\39\\{heap}[\|h]\K\\{heap}[\\{hn}],\39\\{heap}[\\{hn}]\K\|k;{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{for} ${}(\|h\K\T{0};{}$ ${}\|h<\\{vars};{}$ ${}\|h\PP){}$\5
${}\{{}$\1\6
${}\|o,\39\|v\K\\{heap}[\|h];{}$\6
${}\|o,\39\\{vmem}[\|v].\\{hloc}\K\|h;{}$\6
\&{if} ${}(\\{true\_prob\_thresh}\W(\\{mems}\MRL{+{\K}}\T{4},\39\\{gb\_next%
\_rand}(\,)<\\{true\_prob\_thresh})){}$\1\5
${}\\{vmem}[\|v].\\{oldval}\K\T{0};{}$\2\6
\&{else}\1\5
${}\\{vmem}[\|v].\\{oldval}\K\T{1};{}$\2\6
${}\|o,\39\\{vmem}[\|v].\\{activity}\K\T{0.0};{}$\6
\4${}\}{}$\2\6
${}\\{hn}\K\\{vars};{}$\6
\4${}\}{}$\2\par
\U45.\fi

\M{79}Literals that occur in \PB{\\{polarity\_infile}} must be separated by
whitespace,
but they can appear on any number of lines. If the literal isn't in the
hash table, we ignore it. (Perhaps a preprocessor has made this literal
obsolete.)

\Y\B\4\X79:Initialize the heap from a file\X${}\E{}$\6
${}\{{}$\1\6
\&{if} ${}(\\{true\_prob}\G\T{1.0}){}$\1\5
${}\\{true\_prob\_thresh}\K\T{\^80000000};{}$\2\6
\&{else}\1\5
${}\\{true\_prob\_thresh}\K(\&{int})(\\{true\_prob}*\T{2147483648.0});{}$\2\6
\&{for} ${}(\|q\K\T{0};{}$  ; \,)\5
${}\{{}$\1\6
\&{register} \&{tmp\_var} ${}{*}\|p;{}$\7
\&{if} ${}(\\{fscanf}(\\{polarity\_infile},\39\.{""}\|O\.{"s"},\39\\{buf})\I%
\T{1}){}$\1\5
\&{break};\2\6
\&{if} ${}(\\{buf}[\T{0}]\E\.{'\~'}){}$\1\5
${}\|i\K\|j\K\T{1};{}$\2\6
\&{else}\1\5
${}\|i\K\|j\K\T{0};{}$\2\6
\X19:Put the variable name beginning at \PB{\\{buf}[\|j]} in \PB{$\\{cur\_tmp%
\_var}\MG\\{name}$} and compute its hash code \PB{\|h}\X;\6
\&{for} ${}(\|p\K\\{hash}[\|h];{}$ \|p; ${}\|p\K\|p\MG\\{next}){}$\1\6
\&{if} ${}(\|p\MG\\{name}.\\{lng}\E\\{cur\_tmp\_var}\MG\\{name}.\\{lng}){}$\1\5
\&{break};\2\2\6
\&{if} (\|p)\5
${}\{{}$\1\6
${}\|v\K\|p\MG\\{serial}+\T{1};{}$\6
${}\|o,\39\\{vmem}[\|v].\\{oldval}\K\|i,\39\\{vmem}[\|v].\\{hloc}\K\|q;{}$\6
${}\|o,\39\\{heap}[\|q]\K\|v;{}$\6
${}\|o,\39\\{vmem}[\|v].\\{activity}\K(\\{vars}-\|q)/{}$(\&{double}) \\{vars};\6
${}\|o,\39\\{vmem}[\|v].\\{tloc}\K\T{0};{}$\6
${}\|q\PP;{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{for} ${}(\|v\K\T{0};{}$ ${}\|q<\\{vars};{}$ ${}\|q\PP){}$\5
${}\{{}$\1\6
\&{while} ${}(\|o,\39\\{vmem}[\PP\|v].\\{tloc}\E\T{0}){}$\1\5
;\C{ bypass variables already seen }\2\6
${}\\{vmem}[\|v].\\{hloc}\K\|q;{}$\6
\&{if} ${}(\\{true\_prob\_thresh}\W(\\{mems}\MRL{+{\K}}\T{4},\39\\{gb\_next%
\_rand}(\,)<\\{true\_prob\_thresh})){}$\1\5
${}\\{vmem}[\|v].\\{oldval}\K\T{0};{}$\2\6
\&{else}\1\5
${}\\{vmem}[\|v].\\{oldval}\K\T{1};{}$\2\6
${}\|o,\39\\{heap}[\|q]\K\|v;{}$\6
\4${}\}{}$\2\6
${}\\{hn}\K\\{vars};{}$\6
\4${}\}{}$\2\par
\U45.\fi

\M{80}\B\X4:Global variables\X${}\mathrel+\E{}$\6
\&{double} \\{var\_bump}${}\K\T{1.0};{}$\6
\&{float} \\{clause\_bump}${}\K\T{1.0};{}$\6
\&{double} \\{var\_bump\_factor};\C{ reciprocal of \PB{\\{var\_rho}} }\6
\&{float} \\{clause\_bump\_factor};\C{ reciprocal of \PB{\\{clause\_rho}} }\par
\fi

\M{81}Learned clauses also have activity scores. They aren't used as
heavily as the scores for variables; we look at them only when
deciding what clauses to keep after too many learned clauses
have accumulated.

\Y\B\4\X81:Bump \PB{\|c}'s activity\X${}\E{}$\6
${}\{{}$\1\6
\&{float} \\{ac};\7
${}\|o,\39\\{ac}\K\\{activ}(\|c)+\\{clause\_bump};{}$\6
${}\|o,\39\\{activ}(\|c)\K\\{ac};{}$\6
\&{if} ${}(\\{ac}\G\T{1\_20}){}$\1\5
\X84:Rescale all clause activities\X;\2\6
\4${}\}{}$\2\par
\Us87\ET93.\fi

\M{82}\B\X82:Bump the bumps\X${}\E{}$\6
$\\{var\_bump}\MRL{*{\K}}\\{var\_bump\_factor};{}$\6
${}\\{clause\_bump}\MRL{*{\K}}\\{clause\_bump\_factor}{}$;\par
\Us125\ET133.\fi

\M{83}When a nonzero activity is rescaled, we are careful to keep it nonzero
so that a variable once active will not take second place to a totally
inactive variable. (I doubt if this is terrifically important, but
Niklas E\'en told me that he recommends it.)

\Y\B\4\D$\\{tiny}$ \5
\T{2.225073858507201383\_-308}\C{ $2^{-1022}$, the smallest positive
nondenormal \PB{\&{double}} }\par
\Y\B\4\X83:Rescale all variable activities\X${}\E{}$\6
${}\{{}$\1\6
\&{register} \&{int} \|v;\6
\&{register} \&{double} \\{av};\7
\&{for} ${}(\|v\K\T{1};{}$ ${}\|v\Z\\{vars};{}$ ${}\|v\PP){}$\5
${}\{{}$\1\6
${}\|o,\39\\{av}\K\\{vmem}[\|v].\\{activity};{}$\6
\&{if} (\\{av})\1\5
${}\|o,\39\\{vmem}[\|v].\\{activity}\K(\\{av}*\T{1\_-100}<\\{tiny}\?\\{tiny}:%
\\{av}*\T{1\_-100});{}$\2\6
\4${}\}{}$\2\6
${}\\{var\_bump}\MRL{*{\K}}\T{1\_-100};{}$\6
\4${}\}{}$\2\par
\U70.\fi

\M{84}\B\D$\\{single\_tiny}$ \5
\T{1.1754943508222875080\_-38}\C{ $2^{-126}$, the smallest positive nondenormal
\PB{\&{float}} }\par
\Y\B\4\X84:Rescale all clause activities\X${}\E{}$\6
${}\{{}$\1\6
\&{register} \&{int} \\{cc}${},{}$ \\{endc};\7
\&{for} ${}(\\{cc}\K\\{first\_learned};{}$ ${}\\{cc}<\\{max\_learned};{}$ ${}%
\\{cc}\K\\{endc}+\\{learned\_extra}){}$\5
${}\{{}$\1\6
${}\|o,\39\\{endc}\K\\{cc}+\\{size}(\\{cc});{}$\6
${}\|o,\39\\{ac}\K\\{activ}(\\{cc});{}$\6
\&{if} (\\{ac})\1\5
${}\|o,\39\\{activ}(\\{cc})\K(\\{ac}*\T{1\_-20}<\\{single\_tiny}\?\\{single%
\_tiny}:\\{ac}*\T{1\_-20});{}$\2\6
\&{while} ${}(\|o,\39\\{mem}[\\{endc}].\\{lit}\AND\\{sign\_bit}){}$\1\5
${}\\{endc}\PP;{}$\2\6
\4${}\}{}$\2\6
${}\\{clause\_bump}\MRL{*{\K}}\T{1\_-20};{}$\6
\4${}\}{}$\2\par
\U81.\fi

\N{1}{85}Learning from a conflict.
A conflict arises when some clause is found to have no true literals
at the current level. This program relies on a technique for avoiding
such a conflict in the future,
by creating a new clause that is worth learning. Our current
goal is to implement (and thereby to understand) that technique.

Let's say that a literal is ``new'' if it has become true or false at
the current decision level; otherwise it is ``old.'' A conflict must
contain at least two new literals, because we don't start a new level
until every unsatisfied clause is watched by two unassigned literals.

(Hedge: In a ``full run'' we march boldly into deeper levels after
finding conflicts; and in such cases the conflict clauses of level~$d$
are watched by two literals that are false at level~$d$. However,
even in this case, every unsatisfied clause that could lead to a
conflict at a deeper level is watched by two unassigned literals.)

Suppose all literals of $c$ are false. If $\bar l\in c$ and $c'$ is the
reason for $l$, we can resolve $c$ with~$c'$ to get a new clause~$c''$.
This clause~$c''$ is obtained from~$c$ by deleting~$\bar l$ and
then inserting $\bar l'$ for all $l'$ such that $l\succ l'$. (Indeed,
when introducing the method of conflict-driven clause learning above,
we defined this direct dependency relation by saying that $l\succ l'$ if and
only if $\bar l'$ appears in the reason for~$l$.)
Notice that all of the literals that belong to $c''$ are false;
hence $c''$, like~$c$, represents a conflict.

By starting with a conflict clause $c$ and repeatedly
resolving away its rightmost literal, using the ordering of the trail,
we'll eventually obtain
a clause~$c_0$ that has only one new literal. And if $c_0$ was derived by
resolving with other clauses $c_1$, \dots,~$c_k$, the old literals of $c_0$
will be the old literals of $c$, $c_1$, \dots,~$c_k$.

We could now learn the clause $c_0$, and return to decision level~$d$,
the maximum of the levels of $c_0$'s old literals. (Its new literal
will now be forced false at that level.)

Actually, we'll try to simplify $c_0$ before learning it,
by removing some of its old literals if they are redundant. But that's
another story, which we can safely postpone until later. The main idea
is this: Starting with a conflict clause~$c$, containing two or more new
literals, we boil it down to a clause~$c_0$ that contains only one.
Then we can resume at a previous level.

\fi

\M{86}So much for theory; let's proceed to practice. We can use the \PB{%
\\{stamp}}
field to identify literals that appear in the conflict clause~$c$, or in the
clauses derived from~$c$ as we compute~$c_0$: A variable's \PB{\\{stamp}} will
equal \PB{\\{curstamp}} if and only if we have just marked it.
At this point \PB{$\\{llevel}>\T{0}$}.

\Y\B\4\X86:Deal with the conflict clause \PB{\|c}\X${}\E{}$\6
$\\{oldptr}\K\\{jumplev}\K\\{xnew}\K\\{clevels}\K\\{resols}\K\T{0};{}$\6
\X91:Bump \PB{\\{curstamp}} to a new value\X;\6
\&{if} ${}(\\{verbose}\AND\\{show\_gory\_details}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"Preparing\ to\ learn"});{}$\2\6
\&{if} ${}(\|c<\T{0}){}$\1\5
\X88:Initialize a binary conflict\X\2\6
\&{else}\1\5
\X87:Initialize a nonbinary conflict\X;\2\6
\X92:Reduce \PB{\\{xnew}} to zero\X;\6
\&{while} (\T{1})\5
${}\{{}$\1\6
${}\|o,\39\|l\K\\{trail}[\\{tl}\MM];{}$\6
\&{if} ${}(\|o,\39\\{vmem}[\\{thevar}(\|l)].\\{stamp}\E\\{curstamp}){}$\1\5
\&{break};\2\6
\4${}\}{}$\2\6
${}\\{lll}\K\\{bar}(\|l){}$;\C{ \PB{\\{lll}} will complete the learned clause }%
\6
\&{if} ${}(\\{verbose}\AND\\{show\_gory\_details}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"\ "}\|O\.{"s"}\|O\.{".8s\\n"},\39\\{litname}(%
\\{lll})){}$;\2\par
\U125.\fi

\M{87}\B\X87:Initialize a nonbinary conflict\X${}\E{}$\6
${}\{{}$\1\6
${}\|o,\39\|l\K\\{bar}(\\{mem}[\|c].\\{lit});{}$\6
${}\|o,\39\\{tl}\K\\{vmem}[\\{thevar}(\|l)].\\{tloc};{}$\6
${}\|o,\39\\{vmem}[\\{thevar}(\|l)].\\{stamp}\K\\{curstamp};{}$\6
\X70:Bump \PB{\|l}'s activity\X;\6
\&{if} ${}(\|c\G\\{first\_learned}){}$\1\5
\X81:Bump \PB{\|c}'s activity\X;\2\6
\&{for} ${}(\|o,\39\|s\K\\{size}(\|c),\39\|k\K\|c+\|s-\T{1};{}$ ${}\|k>\|c;{}$
${}\|k\MM){}$\5
${}\{{}$\1\6
${}\|o,\39\|l\K\\{bar}(\\{mem}[\|k].\\{lit});{}$\6
${}\|j\K\\{vmem}[\\{thevar}(\|l)].\\{tloc}{}$;\C{ \PB{\\{mem}} will be charged
when fetching \PB{\\{value}} }\6
\&{if} ${}(\|j>\\{tl}){}$\1\5
${}\\{tl}\K\|j;{}$\2\6
\X95:Stamp \PB{\|l} as part of the conflict clause milieu\X;\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U86.\fi

\M{88}Here the conflict is that \PB{\|l} implies \PB{\\{ll}}, where literal %
\PB{$\|l\K{-}\|c$} is
true but literal \PB{\\{ll}} is false.

\Y\B\4\X88:Initialize a binary conflict\X${}\E{}$\6
${}\{{}$\1\6
${}\|o,\39\\{tl}\K\\{vmem}[\\{thevar}(\\{ll})].\\{tloc};{}$\6
${}\|o,\39\\{vmem}[\\{thevar}(\\{ll})].\\{stamp}\K\\{curstamp};{}$\6
${}\|l\K\\{ll};{}$\6
\X70:Bump \PB{\|l}'s activity\X;\6
${}\|l\K{-}\|c;{}$\6
\&{if} ${}(\|o,\39\\{vmem}[\\{thevar}(\|l)].\\{tloc}>\\{tl}){}$\1\5
${}\\{tl}\K\\{vmem}[\\{thevar}(\|l)].\\{tloc};{}$\2\6
${}\|o,\39\\{vmem}[\\{thevar}(\|l)].\\{stamp}\K\\{curstamp};{}$\6
\X70:Bump \PB{\|l}'s activity\X;\6
${}\\{xnew}\K\T{1};{}$\6
\4${}\}{}$\2\par
\U86.\fi

\M{89}\B\X57:Allocate the auxiliary arrays\X${}\mathrel+\E{}$\6
$\\{learn}\K{}$(\&{uint} ${}{*}){}$ \\{malloc}${}(\\{vars}*\&{sizeof}(%
\&{uint}));{}$\6
\&{if} ${}(\R\\{learn}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Oops,\ I\ can't\ alloc}\)\.{ate\ the\ learn\
array!}\)\.{\\n"});{}$\6
${}\\{exit}({-}\T{16});{}$\6
\4${}\}{}$\2\6
${}\\{bytes}\MRL{+{\K}}\\{vars}*\&{sizeof}(\&{uint}){}$;\par
\fi

\M{90}\B\X4:Global variables\X${}\mathrel+\E{}$\6
\&{uint} \\{curstamp};\C{ a unique value for marking literals and levels of
interest }\6
\&{uint} ${}{*}\\{learn}{}$;\C{ literals in a clause being learned }\6
\&{int} \\{oldptr};\C{ this many old literals contributed to learned clause so
far }\6
\&{int} \\{jumplev};\C{ level to which we'll return after learning }\6
\&{int} \\{tl};\C{ trail location for examination of stamped literals }\6
\&{int} \\{xnew};\C{ excess new literals in the current conflict clause }\6
\&{int} \\{clevels};\C{ levels represented in the current conflict clause }\6
\&{uint} \\{resols};\C{ resolutions made while reducing the current conflict
clause }\6
\&{uint} \\{learned\_size};\C{ number of literals in the learned clause }\6
\&{int} \\{prelearned\_size};\C{ \PB{\\{learned\_size}} before simplification }%
\6
\&{int} \\{trivial\_learning};\C{ does the learned clause involve every
decision? }\par
\fi

\M{91}The algorithm that follows will use \PB{\\{curstamp}}, \PB{$\\{curstamp}+%
\T{1}$}, and
\PB{$\\{curstamp}+\T{2}$}.

\Y\B\4\X91:Bump \PB{\\{curstamp}} to a new value\X${}\E{}$\6
\&{if} ${}(\\{curstamp}\G\T{\^fffffffe}){}$\5
${}\{{}$\1\6
\&{for} ${}(\|k\K\T{1};{}$ ${}\|k\Z\\{vars};{}$ ${}\|k\PP){}$\1\5
${}\\{oo},\39\\{vmem}[\|k].\\{stamp}\K\\{levstamp}[\|k+\|k-\T{2}]\K\T{0};{}$\2\6
${}\\{curstamp}\K\T{1};{}$\6
\4${}\}{}$\5
\2\&{else}\1\5
${}\\{curstamp}\MRL{+{\K}}\T{3}{}$;\2\par
\U86.\fi

\M{92}\B\X92:Reduce \PB{\\{xnew}} to zero\X${}\E{}$\6
\&{while} (\\{xnew})\5
${}\{{}$\1\6
\&{while} (\T{1})\5
${}\{{}$\1\6
${}\|o,\39\|l\K\\{trail}[\\{tl}\MM];{}$\6
\&{if} ${}(\|o,\39\\{vmem}[\\{thevar}(\|l)].\\{stamp}\E\\{curstamp}){}$\1\5
\&{break};\2\6
\4${}\}{}$\2\6
${}\\{xnew}\MM;{}$\6
\X93:Resolve with the reason of \PB{\|l}\X;\6
\4${}\}{}$\2\par
\U86.\fi

\M{93}At this point the current conflict clause is represented implicitly
as the set of negatives of the literals \PB{\\{trail}[\|j]} for \PB{$\|j\Z%
\\{tl}$} that
have \PB{$\\{stamp}\K\\{curstamp}$},
together with \PB{\\{bar}(\|l)}. Old literals in that set are in the \PB{%
\\{learn}}
array. The conflict clause contains exactly
\PB{$\\{xnew}+\T{1}$} new literals besides \PB{\\{bar}(\|l)}; we will replace %
\PB{\\{bar}(\|l)}
by the other literals in \PB{\|l}'s reason.

\Y\B\4\X93:Resolve with the reason of \PB{\|l}\X${}\E{}$\6
$\\{resols}\PP;{}$\6
\&{if} ${}(\\{verbose}\AND\\{show\_gory\_details}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"\ ["}\|O\.{"s"}\|O\.{".8s]"},\39\\{litname}(%
\|l));{}$\2\6
${}\|o,\39\|c\K\\{lmem}[\|l].\\{reason};{}$\6
\&{if} ${}(\|c<\T{0}){}$\1\5
\X94:Resolve with binary reason\X\2\6
\&{else} \&{if} (\|c)\5
${}\{{}$\C{ \PB{$\|l\K\\{mem}[\|c].\\{lit}$} }\1\6
\&{if} ${}(\|c\G\\{first\_learned}){}$\1\5
\X81:Bump \PB{\|c}'s activity\X;\2\6
\&{for} ${}(\|o,\39\|s\K\\{size}(\|c),\39\|k\K\|c+\|s-\T{1};{}$ ${}\|k>\|c;{}$
${}\|k\MM){}$\5
${}\{{}$\1\6
${}\|o,\39\|l\K\\{bar}(\\{mem}[\|k].\\{lit});{}$\6
\&{if} ${}(\|o,\39\\{vmem}[\\{thevar}(\|l)].\\{stamp}\I\\{curstamp}){}$\1\5
\X95:Stamp \PB{\|l} as part of the conflict clause milieu\X;\2\6
\4${}\}{}$\2\6
\&{if} ${}(\\{xnew}+\\{oldptr}+\T{1}<\|s\W\\{xnew}){}$\1\5
\X98:Subsume \PB{\|c} by removing its first literal\X;\2\6
\4${}\}{}$\2\par
\U92.\fi

\M{94}\B\X94:Resolve with binary reason\X${}\E{}$\6
${}\{{}$\1\6
${}\|l\K{-}\|c;{}$\6
\&{if} ${}(\|o,\39\\{vmem}[\\{thevar}(\|l)].\\{stamp}\I\\{curstamp}){}$\1\5
\X95:Stamp \PB{\|l} as part of the conflict clause milieu\X;\2\6
\4${}\}{}$\2\par
\U93.\fi

\M{95}\B\X95:Stamp \PB{\|l} as part of the conflict clause milieu\X${}\E{}$\6
${}\{{}$\1\6
${}\|o,\39\\{jj}\K\\{vmem}[\\{thevar}(\|l)].\\{value}\AND{-}\T{2};{}$\6
\&{if} ${}(\R\\{jj}){}$\1\5
\\{confusion}(\.{"permanently\ false\ l}\)\.{it"});\2\6
\&{else}\5
${}\{{}$\1\6
${}\|o,\39\\{vmem}[\\{thevar}(\|l)].\\{stamp}\K\\{curstamp};{}$\6
\X70:Bump \PB{\|l}'s activity\X;\6
\&{if} ${}(\\{jj}\G\\{llevel}){}$\1\5
${}\\{xnew}\PP;{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{if} ${}(\\{jj}>\\{jumplev}){}$\1\5
${}\\{jumplev}\K\\{jj};{}$\2\6
${}\|o,\39\\{learn}[\\{oldptr}\PP]\K\\{bar}(\|l);{}$\6
\&{if} ${}(\\{verbose}\AND\\{show\_gory\_details}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"\ "}\|O\.{"s"}\|O\.{".8s\{"}\|O\.{"d\}"},\39%
\\{litname}(\\{bar}(\|l)),\39\\{vmem}[\\{thevar}(\|l)].\\{value}\GG\T{1});{}$\2%
\6
\&{if} ${}(\|o,\39\\{levstamp}[\\{jj}]<\\{curstamp}){}$\1\5
${}\|o,\39\\{levstamp}[\\{jj}]\K\\{curstamp},\39\\{clevels}\PP;{}$\2\6
\&{else} \&{if} ${}(\\{levstamp}[\\{jj}]\E\\{curstamp}){}$\1\5
${}\|o,\39\\{levstamp}[\\{jj}]\K\\{curstamp}+\T{1};{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\Us87, 93\ETs94.\fi

\M{96}The \PB{\\{stack}} and \PB{\\{conflictdat}} arrays have
enough room for twice the number of variables in the worst case.

The \PB{\\{levstamp}} array also has that same size. We use its even-numbered
slots
when learning and its odd-numbered slots when recycling.

\Y\B\4\X57:Allocate the auxiliary arrays\X${}\mathrel+\E{}$\6
$\\{stack}\K{}$(\&{int} ${}{*}){}$ \\{malloc}${}(\\{vars}*\T{2}*\&{sizeof}(%
\&{int}));{}$\6
\&{if} ${}(\R\\{stack}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Oops,\ I\ can't\ alloc}\)\.{ate\ the\ stack\
array!}\)\.{\\n"});{}$\6
${}\\{exit}({-}\T{16});{}$\6
\4${}\}{}$\2\6
${}\\{bytes}\MRL{+{\K}}\\{vars}*\T{2}*\&{sizeof}(\&{int});{}$\6
${}\\{conflictdat}\K{}$(\&{int} ${}{*}){}$ \\{malloc}${}(\\{vars}*\T{2}*%
\&{sizeof}(\&{int}));{}$\6
\&{if} ${}(\R\\{conflictdat}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Oops,\ I\ can't\ alloc}\)\.{ate\ the\
conflictdat\ }\)\.{array!\\n"});{}$\6
${}\\{exit}({-}\T{16});{}$\6
\4${}\}{}$\2\6
${}\\{bytes}\MRL{+{\K}}\\{vars}*\T{2}*\&{sizeof}(\&{int});{}$\6
${}\\{levstamp}\K{}$(\&{uint} ${}{*}){}$ \\{malloc}${}(\T{2}*\\{vars}*%
\&{sizeof}(\&{uint}));{}$\6
\&{if} ${}(\R\\{levstamp}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Oops,\ I\ can't\ alloc}\)\.{ate\ the\ levstamp%
\ arr}\)\.{ay!\\n"});{}$\6
${}\\{exit}({-}\T{16});{}$\6
\4${}\}{}$\2\6
${}\\{bytes}\MRL{+{\K}}\T{2}*\\{vars}*\&{sizeof}(\&{uint});{}$\6
\&{for} ${}(\|k\K\T{0};{}$ ${}\|k<\\{vars};{}$ ${}\|k\PP){}$\1\5
${}\|o,\39\\{levstamp}[\|k+\|k]\K\T{0}{}$;\2\par
\fi

\M{97}\B\X4:Global variables\X${}\mathrel+\E{}$\6
\&{int} ${}{*}\\{stack}{}$;\C{ place for homemade recursion control }\6
\&{int} \\{stackptr};\C{ number of elements in the stack }\6
\&{int} ${}{*}\\{conflictdat}{}$;\C{ recorded data about conflicts in full runs
}\6
\&{int} \\{conflict\_level};\C{ pointer to top of the recorded conflict stack }%
\6
\&{uint} ${}{*}\\{levstamp}{}$;\C{ memos for recursive answers; also binary
conflict info }\par
\fi

\M{98}Here now is the technique of ``on-the-fly subsumption,'' which allows us
to strengthen the clause \PB{\|c} because it happens to contain the current
conflict clause.
[This technique was discovered by Han and Somenzi in America, and
independently by Hamadi, Jabbour, and Sa{\"\i}s in Europe,
both in 2009!]

The current conflict has been obtained by resolving \PB{\|c} with another
clause,
and by removing literals that are false at level~0. We've also removed
such literals from~\PB{\|c}. Therefore we know that the current conflict clause
equals \PB{\|c} minus its first literal (which is true and was resolved away).

Clause \PB{\|c} is the reason for \PB{\|l}, and it becomes the reason for a
false literal that would have produced an earlier conflict.
(That false literal must have become false at the current trail level.)
We don't have to update the reason data, because backtracking will
clear it out before it will be needed.

There are strange scenarios in which \PB{$\|c\K\\{prev\_learned}$} and the
newly
learned clause might duplicate the previous one. The previous one
won't be removed unless we now happen to be watching the literal that will
later be called \PB{\\{bar}(\\{lll})}.

\Y\B\4\X98:Subsume \PB{\|c} by removing its first literal\X${}\E{}$\6
${}\{{}$\1\6
${}\|l\K\\{mem}[\|c].\\{lit}{}$;\C{ no mem charged; we already knew this
literal }\6
${}\|o,\39\\{size}(\|c)\K\MM\|s,\39\\{subsumptions}\PP;{}$\6
\&{if} ${}(\\{learned\_file}\W\|s\Z\\{learn\_save}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{learned\_file},\39\.{"\ "}){}$;\C{ this space identifies a
subsumer }\6
\&{for} ${}(\|k\K\|c+\T{1};{}$ ${}\|k\Z\|c+\|s;{}$ ${}\|k\PP){}$\1\5
${}\\{fprintf}(\\{learned\_file},\39\.{"\ "}\|O\.{"s"}\|O\.{".8s"},\39%
\\{litname}(\\{mem}[\|k].\\{lit}));{}$\2\6
${}\\{fprintf}(\\{learned\_file},\39\.{"\\n"});{}$\6
\\{fflush}(\\{learned\_file});\6
${}\\{learned\_out}\PP;{}$\6
\4${}\}{}$\2\6
${}\|o,\39\|r\K\\{link0}(\|c);{}$\6
\X106:Remove \PB{\|c} from \PB{\|l}'s watch list\X;\6
${}\|o,\39\\{ll}\K\\{mem}[\|c+\|s].\\{lit}{}$;\C{ this false literal will now
be moved elsewhere }\6
\&{for} ${}(\\{lll}\K\\{ll},\39\|k\K\|c+\|s;{}$  ; ${}\|k\MM){}$\5
${}\{{}$\C{ \PB{$\\{lll}\K\\{mem}[\|k].\\{lit}$} }\1\6
${}\|o,\39\|r\K\\{vmem}[\\{thevar}(\\{lll})].\\{value}\AND{-}\T{2};{}$\6
\&{if} ${}(\|r\E\\{llevel}){}$\1\5
\&{break};\2\6
${}\|o,\39\\{lll}\K\\{mem}[\|k-\T{1}].\\{lit};{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{lll}\I\\{ll}){}$\1\5
${}\|o,\39\\{mem}[\|k].\\{lit}\K\\{ll};{}$\2\6
${}\\{oo},\39\\{mem}[\|c+\|s].\\{lit}\K\|l+\\{sign\_bit},\39\\{mem}[\|c].%
\\{lit}\K\\{lll};{}$\6
${}\\{ooo},\39\\{link0}(\|c)\K\\{lmem}[\\{lll}].\\{watch},\39\\{lmem}[\\{lll}].%
\\{watch}\K\|c;{}$\6
\&{if} ${}(\\{verbose}\AND\\{show\_watches}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"\ ["}\|O\.{"s"}\|O\.{".8s\ watches\ "}\|O%
\.{"d]"},\39\\{litname}(\\{lll}),\39\|c);{}$\2\6
\4${}\}{}$\2\par
\U93.\fi

\N{1}{99}Simplifying the learned clause.
Suppose the clause to be learned is $\bar l\lor\bar a_1\lor\cdots\lor\bar a_k$.
Many of the literals $\bar a_j$ often turn out to be redundant, in the sense
that a few well-chosen resolutions will remove them.

For example, if the reason of $a_4$ is $a_4\lor\bar a_1\lor\bar b_1$ and
the reason of~$b_1$ is $b_1\lor\bar a_2\lor\bar b_2$ and the reason of~$b_2$
is $b_2\lor\bar a_1\lor\bar a_3$, then $\bar a_4$ is redundant.

Niklas S\"orensson, one of the authors of MiniSAT, noticed that learned
clauses could typically be shortened by 30\% when such simplifications are
made. Therefore we certainly want to look for removable literals, even though
the algorithm for doing so is somewhat tricky.

The literal $\bar a$ is redundant in the clause-to-be-learned if and only if
the other literals in its reason are either present in that clause
or (recursively) redundant. (In the example above we must check that
$\bar a_1$ and $\bar b_1$ satisfy this condition; that boils down to
observing that $\bar b_1$ is redundant, because $\bar b_2$ is redundant.)

Since the relation $\sucp$ is a partial ordering, we can determine
redundancy by using a ``bottom up'' method with this recursive definition.
Or we can go ``top down'' with memoization (which is what we'll do):
We shall stamp a literal $b$ with \PB{$\\{curstamp}+\T{1}$} if $\bar b$ is
known to
be redundant, and with \PB{$\\{curstamp}+\T{2}$} if $\bar b$ is known to be
nonredundant.
Once we know a literal's status, we won't need to apply the recursive
definition again.

A nice trick (also due to S\"orensson) can be used to speed this process up,
using the fact that a non-decision literal always depends on at least one
other literal at the same level: A literal $\bar a_j$ can be redundant
only if it shares a level with some other literal $\bar a_i$ in the
learned clause. Furthermore, a literal $\bar b$ not in that clause can be
redundant only if it shares a level with some~$\bar a_j$.

A careful reader of the code in the previous sections will have noticed
that we've set \PB{$\\{levstamp}[\|t+\|t]\K\\{curstamp}$} if level~\PB{\|t}
contains exactly one
of the literals $\bar a_j$, and we've set \PB{$\\{levstamp}[\|t+\|t]\K%
\\{curstamp}+\T{1}$}
if it contains more than one. Those facts will help us decide non-redundancy
without pursuing the whole recursion into impossible levels.

\fi

\M{100}Instead of doing this computation with a recursive procedure, I want
to control the counting of memory accesses, and to take advantage of
the special logical structure that's present. So the program here uses an
explicit stack to hold the parameters of unfinished queries.

When we enter this section, \PB{\\{stackptr}} will be zero (it says here).
When we leave it, whether by going to \PB{\\{redundant}} or not,
the original value of~\PB{\|l} will be in~\PB{\\{ll}}.
I~think this loop makes an instructive
example of how recursion relates to iteration.

One can prove inductively that, at label \PB{\\{test}}, we have
\PB{$\\{vmem}[\\{thevar}(\|l)].\\{stamp}\Z\\{curstamp}$}, with equality if and
only if \PB{$\\{stackptr}\K\T{0}$}.

\Y\B\4\X100:If $\bar l$ is redundant, \PB{\&{goto} \\{redundant}}\X${}\E{}$\6
\&{if} (\\{stackptr})\1\5
\\{confusion}(\.{"stack"});\2\6
\4\\{test}:\5
${}\\{ll}\K\|l;{}$\6
${}\|o,\39\|c\K\\{lmem}[\|l].\\{reason};{}$\6
\&{if} ${}(\|c\E\T{0}){}$\1\5
\&{goto} \\{clear\_stack};\C{ decision literal is never redundant }\2\6
\&{if} ${}(\|c<\T{0}){}$\5
${}\{{}$\C{ binary reason }\1\6
${}\|l\K\\{bar}({-}\|c);{}$\6
${}\|o,\39\|s\K\\{vmem}[\\{thevar}(\|l)].\\{stamp};{}$\6
\&{if} ${}(\|s\G\\{curstamp}){}$\5
${}\{{}$\1\6
\&{if} ${}(\|s\E\\{curstamp}+\T{2}){}$\1\5
\&{goto} \\{clear\_stack};\C{ known non-redundant }\2\6
\4${}\}{}$\5
\2\&{else}\5
${}\{{}$\1\6
${}\|o,\39\\{stack}[\\{stackptr}\PP]\K\\{ll};{}$\6
\&{goto} \\{test};\6
\4${}\}{}$\2\6
\4${}\}{}$\5
\2\&{else}\5
${}\{{}$\1\6
\&{for} ${}(\|o,\39\|k\K\|c+\\{size}(\|c)-\T{1};{}$ ${}\|k>\|c;{}$ ${}\|k%
\MM){}$\5
${}\{{}$\1\6
${}\\{oo},\39\|l\K\\{bar}(\\{mem}[\|k].\\{lit}),\39\|s\K\\{vmem}[\\{thevar}(%
\|l)].\\{stamp};{}$\6
\&{if} ${}(\|s\G\\{curstamp}){}$\5
${}\{{}$\1\6
\&{if} ${}(\|s\E\\{curstamp}+\T{2}){}$\1\5
\&{goto} \\{clear\_stack};\C{ known non-redundant }\2\6
\&{continue};\C{ in learned clause or known redundant }\6
\4${}\}{}$\2\6
${}\|o,\39\|s\K\\{vmem}[\\{thevar}(\|l)].\\{value}\AND{-}\T{2};{}$\6
\&{if} ${}(\|s\E\T{0}){}$\1\5
\&{continue};\C{ literals on level 0 are redundant }\2\6
${}\|o,\39\|s\K\\{levstamp}[\|s];{}$\6
\&{if} ${}(\|s<\\{curstamp}){}$\5
${}\{{}$\C{ the level is bad }\1\6
${}\|o,\39\\{vmem}[\\{thevar}(\|l)].\\{stamp}\K\\{curstamp}+\T{2};{}$\6
\&{goto} \\{clear\_stack};\6
\4${}\}{}$\2\6
${}\|o,\39\\{stack}[\\{stackptr}]\K\|k,\39\\{stack}[\\{stackptr}+\T{1}]\K%
\\{ll},\39\\{stackptr}\MRL{+{\K}}\T{2};{}$\6
\&{goto} \\{test};\6
\4\\{test1}:\5
\&{continue};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4\\{is\_red}:\5
${}\|o,\39\\{vmem}[\\{thevar}(\\{ll})].\\{stamp}\K\\{curstamp}+\T{1}{}$;\C{
we've proved \PB{\\{bar}(\\{ll})} redundant }\6
\&{if} (\\{stackptr})\5
${}\{{}$\1\6
${}\\{oo},\39\\{ll}\K\\{stack}[\MM\\{stackptr}],\39\|c\K\\{lmem}[\\{ll}].%
\\{reason};{}$\6
\&{if} ${}(\|c<\T{0}){}$\1\5
\&{goto} \\{is\_red};\2\6
${}\|o,\39\|k\K\\{stack}[\MM\\{stackptr}];{}$\6
\&{goto} \\{test1};\C{ jump back into the loop }\6
\4${}\}{}$\2\6
\&{goto} \\{redundant};\6
\X101:Clear the stack\X;\par
\U102.\fi

\M{101}If any of the literals we encounter during that recursive exploration
are non-redundant, the literal \PB{\\{ll}} we're currently working on is
non-redundant, and so are all of the literals on the stack.

(The literal at the bottom of the stack belongs to the learned clause,
so we keep its stamp equal to \PB{\\{curstamp}}. The other literals, whose
stamp was less than \PB{\\{curstamp}}, are now marked with \PB{$\\{curstamp}+%
\T{2}$}.)

\Y\B\4\X101:Clear the stack\X${}\E{}$\6
\4\\{clear\_stack}:\5
\&{if} (\\{stackptr})\5
${}\{{}$\1\6
${}\|o,\39\\{vmem}[\\{thevar}(\\{ll})].\\{stamp}\K\\{curstamp}+\T{2};{}$\6
${}\|o,\39\\{ll}\K\\{stack}[\MM\\{stackptr}];{}$\6
${}\|o,\39\|c\K\\{lmem}[\\{ll}].\\{reason};{}$\6
\&{if} ${}(\|c>\T{0}){}$\1\5
${}\\{stackptr}\MM;{}$\2\6
\&{goto} \\{clear\_stack};\6
\4${}\}{}$\2\par
\U100.\fi

\M{102}Sometimes the learned clause turns out to be unnecessarily long even
after we simplify it. This can happen, for example, if the decision
literal~\PB{\|l} on level~1 is not part of the clause, but all the other
literals
have a reason that depends on~\PB{\|l}; then no literal is redundant, by our
definitions, yet many literals can be from the same level.

If the learned clause size exceeds the jump level plus~\PB{\\{trivial\_limit}},
we
replace it
by a ``trivial'' clause based on decision literals only. (In such cases
we are essentially doing no better than an ordinary backtrack algorithm.)

\Y\B\4\X102:Simplify the learned clause\X${}\E{}$\6
$\\{learned\_size}\K\\{oldptr}+\T{1};{}$\6
${}\\{cells\_prelearned}\MRL{+{\K}}\\{learned\_size},\39\\{prelearned\_size}\K%
\\{learned\_size};{}$\6
\&{for} ${}(\\{kk}\K\T{0};{}$ ${}\\{kk}<\\{oldptr};{}$ ${}\\{kk}\PP){}$\5
${}\{{}$\1\6
${}\|o,\39\|l\K\\{bar}(\\{learn}[\\{kk}]);{}$\6
${}\\{oo},\39\|s\K\\{levstamp}[\\{vmem}[\\{thevar}(\|l)].\\{value}\AND{-}%
\T{2}];{}$\6
\&{if} ${}(\|s<\\{curstamp}+\T{1}){}$\1\5
\&{continue};\C{ \PB{\|l}'s level doesn't support redundancy }\2\6
\X100:If $\bar l$ is redundant, \PB{\&{goto} \\{redundant}}\X;\6
\&{continue};\6
\4\\{redundant}:\5
${}\\{learned\_size}\MM;{}$\6
\&{if} ${}(\\{verbose}\AND\\{show\_gory\_details}{}$)\C{ note that \PB{\|l} has
been moved to \PB{\\{ll}} }\1\6
${}\\{fprintf}(\\{stderr},\39\.{"("}\|O\.{"s"}\|O\.{".8s\ is\ redundant)\\n}\)%
\.{"},\39\\{litname}(\\{bar}(\\{ll})));{}$\2\6
\4${}\}{}$\2\6
\&{if} ${}(\\{learned\_size}\Z(\\{jumplev}\GG\T{1})+\\{trivial\_limit}){}$\1\5
${}\\{trivial\_learning}\K\T{0};{}$\2\6
\&{else}\1\5
${}\\{trivial\_learning}\K\T{1},\39\\{clevels}\K\\{jumplev}\GG\T{1},\39%
\\{learned\_size}\K\\{clevels}+\T{1},\39\\{trivials}\PP;{}$\2\6
${}\\{cells\_learned}\MRL{+{\K}}\\{learned\_size},\39\\{total\_learned}\PP;{}$\6
\X40:Update the smoothed-average stats after a clause has been learned\X;\par
\U125.\fi

\M{103}The following code is used only when \PB{$\\{learned\_size}>\T{1}$}.
(Learned
unit clauses are, of course, happy events; but we deal with them separately.)

The new clause must be watched by two literals. One literal in this
clause, namely~\PB{\\{lll}}, was formerly false but it will become true.
It's the one that survived from the conflict
on the active level, and it will be one of the watchers we need.

All other literals in the learned clause are currently false. We must
choose one of those on the highest level (furthest from root level)
to be a watcher. For if we don't, backtracking might take us to
a lower level on which the clause becomes forcing, yet we won't
see that fact --- we won't be watching it! (The true literal and
an unwatched literal become unassigned during backtracking.
Then, if the unwatched literal
becomes false, we won't notice that the formerly true literal
is now forced true again.)

\Y\B\4\X103:Learn the simplified clause\X${}\E{}$\6
${}\{{}$\1\6
\X104:Determine the address, \PB{\|c}, for the learned clause\X;\6
\X107:Store the learned clause \PB{\|c}\X;\6
${}\\{prev\_learned}\K\|c;{}$\6
\&{if} ${}(\\{learned\_file}\W\\{learned\_size}\Z\\{learn\_save}){}$\1\5
\X108:Output \PB{\|c} to the file of learned clauses\X;\2\6
\4${}\}{}$\2\par
\Us125\ET134.\fi

\M{104}In early runs of this program, I noticed several times when the
previously
learned clause is immediately subsumed by the next clause to be learned.
On further inspection, it turned out that this happened when the
previously learned clause was the reason for a literal on a level that
is going away (because \PB{\\{jumplev}} is smaller).

So I now check for this case. Backtracking has already zeroed out this
literal's reason.

\Y\B\4\X104:Determine the address, \PB{\|c}, for the learned clause\X${}\E{}$\6
\&{if} (\\{prev\_learned})\5
${}\{{}$\1\6
${}\|o,\39\|l\K\\{mem}[\\{prev\_learned}].\\{lit};{}$\6
\&{if} ${}(\R\\{trivial\_learning}\W(\|o,\39\\{lmem}[\|l].\\{reason}\E\T{0})\W(%
\|o,\39\\{vmem}[\\{thevar}(\|l)].\\{value}\E\\{unset})){}$\1\5
\X105:Discard clause \PB{\\{prev\_learned}} if it is subsumed by the current
learned clause\X;\2\6
\4${}\}{}$\2\6
${}\|c\K\\{max\_learned}{}$;\C{ this will be the address of the new clause }\6
${}\|o,\39\\{mem}[\|c+\\{learned\_size}].\\{lit}\K\T{0}{}$;\C{ put zero at end
of \PB{\\{mem}} }\6
${}\\{max\_learned}\MRL{+{\K}}\\{learned\_size}+\\{learned\_extra};{}$\6
\&{if} ${}(\\{max\_learned}>\\{max\_cells\_used}){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{max\_learned}\G\\{memsize}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Memory\ overflow\ (me}\)\.{msize="}\|O\.{"u<"}%
\|O\.{"u),\ please\ increase}\)\.{\ m!\\n"},\39\\{memsize},\39\\{max\_cells%
\_used}+\T{1});{}$\6
${}\\{exit}({-}\T{666});{}$\6
\4${}\}{}$\2\6
${}\\{bytes}\MRL{+{\K}}(\\{max\_learned}-\\{max\_cells\_used})*\&{sizeof}(%
\&{cel});{}$\6
${}\\{max\_cells\_used}\K\\{max\_learned};{}$\6
\4${}\}{}$\2\par
\U103.\fi

\M{105}The first literal of \PB{\\{prev\_learned}} has no set value, so it
isn't
part of the conflict clause. We will discard \PB{\\{prev\_learned}} if all
literals of the learned clause appear among the {\it other\/} literals of
\PB{\\{prev\_learned}}.

\Y\B\4\X105:Discard clause \PB{\\{prev\_learned}} if it is subsumed by the
current learned clause\X${}\E{}$\6
${}\{{}$\1\6
\&{for} ${}(\|o,\39\|k\K\\{size}(\\{prev\_learned})-\T{1},\39\|q\K\\{learned%
\_size};{}$ ${}\|q\W\|k\G\|q;{}$ ${}\|k\MM){}$\5
${}\{{}$\1\6
${}\\{oo},\39\|l\K\\{mem}[\\{prev\_learned}+\|k].\\{lit},\39\|r\K\\{vmem}[%
\\{thevar}(\|l)].\\{value}\AND{-}\T{2};{}$\6
\&{if} ${}((\|l\E\\{lll}\V{}$(\&{uint}) \|r${}\Z\\{jumplev})\W(\|o,\39\\{vmem}[%
\\{thevar}(\|l)].\\{stamp}\E\\{curstamp})){}$\1\5
${}\|q\MM{}$;\C{ yes, \PB{\|l} is in the learned clause }\2\6
\4${}\}{}$\2\6
\&{if} ${}(\|q\E\T{0}){}$\5
${}\{{}$\1\6
${}\\{max\_learned}\K\\{prev\_learned}{}$;\C{ forget the previously learned
clause }\6
\&{if} ${}(\\{verbose}\AND\\{show\_gory\_details}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"(clause\ "}\|O\.{"d\ discarded)\\n"},\39%
\\{prev\_learned});{}$\2\6
${}\\{discards}\PP;{}$\6
${}\|o,\39\|c\K\\{prev\_learned},\39\\{activ}(\|c)\K\T{0};{}$\6
${}\|o,\39\|l\K\\{mem}[\|c].\\{lit},\39\|r\K\\{link0}(\|c);{}$\6
\X106:Remove \PB{\|c} from \PB{\|l}'s watch list\X;\6
${}\\{oo},\39\|l\K\\{mem}[\|c+\T{1}].\\{lit},\39\|r\K\\{link1}(\|c);{}$\6
\X106:Remove \PB{\|c} from \PB{\|l}'s watch list\X;\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U104.\fi

\M{106}At this point \PB{\|r} is the successor of \PB{\|c} in the watch list.

\Y\B\4\X106:Remove \PB{\|c} from \PB{\|l}'s watch list\X${}\E{}$\6
\&{for} ${}(\|o,\39\\{wa}\K\\{lmem}[\|l].\\{watch},\39\|q\K\T{0};{}$ ${}\\{wa}%
\I\|c;{}$ ${}\|q\K\\{wa},\39\\{wa}\K\\{next\_wa}){}$\5
${}\{{}$\1\6
${}\|o,\39\|p\K\\{mem}[\\{wa}].\\{lit};{}$\6
${}\|o,\39\\{next\_wa}\K(\|p\E\|l\?\\{link0}(\\{wa}):\\{link1}(\\{wa}));{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\R\|q){}$\1\5
${}\|o,\39\\{lmem}[\|l].\\{watch}\K\|r;{}$\2\6
\&{else} \&{if} ${}(\|p\E\|l){}$\1\5
${}\|o,\39\\{link0}(\|q)\K\|r;{}$\2\6
\&{else}\1\5
${}\|o,\39\\{link1}(\|q)\K\|r{}$;\2\par
\Us98\ET105.\fi

\M{107}\B\X107:Store the learned clause \PB{\|c}\X${}\E{}$\6
\&{if} (\\{activ}(\|c))\1\5
\\{confusion}(\.{"bumps"});\2\6
${}\\{size}(\|c)\K\\{learned\_size}{}$;\C{ no mem need be charged here, since
we're charging for \PB{\\{link0}}, \PB{\\{link1}} }\6
${}\|o,\39\\{mem}[\|c].\\{lit}\K\\{lll};{}$\6
${}\\{oo},\39\\{link0}(\|c)\K\\{lmem}[\\{lll}].\\{watch};{}$\6
${}\|o,\39\\{lmem}[\\{lll}].\\{watch}\K\|c;{}$\6
\&{if} (\\{trivial\_learning})\5
${}\{{}$\1\6
\&{for} ${}(\|j\K\T{1},\39\|k\K\\{jumplev};{}$ \|k; ${}\|j\PP,\39\|k\MRL{-{\K}}%
\T{2}){}$\5
${}\{{}$\1\6
${}\\{oo},\39\|l\K\\{bar}(\\{trail}[\\{leveldat}[\|k]]);{}$\6
\&{if} ${}(\|j\E\T{1}){}$\1\5
${}\\{ooo},\39\\{link1}(\|c)\K\\{lmem}[\|l].\\{watch},\39\\{lmem}[\|l].%
\\{watch}\K\|c;{}$\2\6
${}\|o,\39\\{mem}[\|c+\|j].\\{lit}\K\|l;{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{verbose}\AND\\{show\_gory\_details}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"(trivial\ clause\ is\ }\)\.{substituted)%
\\n"});{}$\2\6
\4${}\}{}$\5
\2\&{else}\1\6
\&{for} ${}(\|k\K\T{1},\39\|j\K\T{0},\39\\{jj}\K\T{1};{}$ ${}\|k<\\{learned%
\_size};{}$ ${}\|j\PP){}$\5
${}\{{}$\1\6
${}\|o,\39\|l\K\\{learn}[\|j];{}$\6
\&{if} ${}(\|o,\39\\{vmem}[\\{thevar}(\|l)].\\{stamp}\E\\{curstamp}){}$\5
${}\{{}$\C{ not redundant }\1\6
${}\|o,\39\|r\K\\{vmem}[\\{thevar}(\|l)].\\{value};{}$\6
\&{if} ${}(\\{jj}\W\|r\G\\{jumplev}){}$\5
${}\{{}$\1\6
${}\|o,\39\\{mem}[\|c+\T{1}].\\{lit}\K\|l;{}$\6
${}\\{oo},\39\\{link1}(\|c)\K\\{lmem}[\|l].\\{watch};{}$\6
${}\|o,\39\\{lmem}[\|l].\\{watch}\K\|c;{}$\6
${}\\{jj}\K\T{0};{}$\6
\4${}\}{}$\5
\2\&{else}\1\5
${}\|o,\39\\{mem}[\|c+\|k+\\{jj}].\\{lit}\K\|l;{}$\2\6
${}\|k\PP;{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\2\par
\U103.\fi

\M{108}\B\X108:Output \PB{\|c} to the file of learned clauses\X${}\E{}$\6
${}\{{}$\1\6
\&{for} ${}(\|k\K\|c;{}$ ${}\|k<\|c+\\{learned\_size};{}$ ${}\|k\PP){}$\1\5
${}\\{fprintf}(\\{learned\_file},\39\.{"\ "}\|O\.{"s"}\|O\.{".8s"},\39%
\\{litname}(\\{mem}[\|k].\\{lit}));{}$\2\6
${}\\{fprintf}(\\{learned\_file},\39\.{"\\n"});{}$\6
\\{fflush}(\\{learned\_file});\6
${}\\{learned\_out}\PP;{}$\6
\4${}\}{}$\2\par
\U103.\fi

\N{1}{109}Recycling unhelpful clauses.
After thousands of conflicts have occurred, we have learned thousands of new
clauses. New clauses guide the search by steering us away from unproductive
paths; but they also slow down the propagation process because we have to
watch them.

Therefore we try to rank the clauses that have accumulated, and we
periodically attempt to weed out the ones that appear to be hurting us more
than they help.

This program assesses the utility of learned clauses by using a
heuristic measure of quality inspired by the paper of
Gilles Audemard and Laurent Simon in {\sl IJCAI\/ \bf21} (2009), 399-404.
Suppose the literals of clause \PB{\|c} appear on exactly $p+q$ distinct levels
of
the trail, where there's at least one true literal in $p$ of those levels,
but all literals of the other $q$ levels are false. Then we give \PB{\|c} the
score $p+\alpha q$, called its ``range.''
Heuristically, this range will tend to be small if
\PB{\|c} is going to participate in future forcing operations.

The parameter $\alpha$ equals 0.2 by default, but users can tune it to
their heart's content, as long as $0\le\alpha\le1$.
Audemard and Simon considered only the case $\alpha=1$
in their paper, calling $p+q$ the ``literal block distance'' of~\PB{\|c}.
% they said "literals blocks distance" but improved it in 2011
Smaller values of~$\alpha$ appeared to give even better results, in
my early tests; however, I've had mixed results since then.
Certainly $\alpha=0$ is too small, because $p$ tends to have a limited range
and $q$~is needed to break ties. Similarly, I~think $\alpha=1$ is inadvisable,
because $p$~is needed to break ties in clauses with the same literal
block distance.

If a learned clause is currently used as the reason for some literal in the
trail, we must keep it: That clause is ``asserting.'' So we give it
range~0. (Except at root level.)

Armin Biere has advised me not to recycle clauses of size 3 or less.
But this program doesn't make any special provision for such clauses,
because they will almost surely stick around as a consequence of the
range heuristic.

Let's suppose that we
have accumulated $h$ learned clauses in~\PB{\\{mem}}, and that we want
to reduce that number from $h$ to~$h/2$. We shall do that by retaining
those clauses whose range lies below the median range.

A precise determination of the median isn't necessary, because ranges are
only heuristic. We actually convert the range to an 8-bit number by computing
$\min\bigl(\lfloor16(p+\alpha q)\rfloor,255\bigr)$. (All ranges of 16 or more
are therefore considered to be equally bad.) Knowing the distribution of these
scaled ranges then makes it easy to select the smallest ones.

\Y\B\4\D$\\{buckets}$ \5
\T{256}\C{ number of distinct range levels after scaling }\par
\B\4\D$\\{badlevel}$ \5
\T{16.0}\C{ ranges greater than this are essentially infinite }\par
\Y\B\4\X57:Allocate the auxiliary arrays\X${}\mathrel+\E{}$\6
$\\{rangedist}\K{}$(\&{int} ${}{*}){}$ \\{malloc}${}(\\{buckets}*\&{sizeof}(%
\&{int}));{}$\6
\&{if} ${}(\R\\{rangedist}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Oops,\ I\ can't\ alloc}\)\.{ate\ the\
rangedist\ ar}\)\.{ray!\\n"});{}$\6
${}\\{exit}({-}\T{16});{}$\6
\4${}\}{}$\2\6
${}\\{bytes}\MRL{+{\K}}\\{buckets}*\&{sizeof}(\&{int});{}$\6
\&{for} ${}(\|k\K\T{0};{}$ ${}\|k+\|k<\\{buckets};{}$ ${}\|k\PP){}$\1\5
${}\|o,\39\\{rangedist}[\|k+\|k]\K\\{rangedist}[\|k+\|k+\T{1}]\K\T{0}{}$;\2\par
\fi

\M{110}The following program computes the scaled range by using
the auxiliary array \PB{\\{levstamp}} to identify levels that have been seen
before. All odd-numbered entries of \PB{\\{levstamp}} should be less than~\PB{%
\|c} when
this code begins.

\Y\B\4\X110:Compute the scaled range of \PB{\|c}\X${}\E{}$\6
${}\{{}$\1\6
${}\|o,\39\|l\K\\{mem}[\|c].\\{lit};{}$\6
\&{if} ${}(\|o,\39\\{lmem}[\|l].\\{reason}\E\|c){}$\5
${}\{{}$\1\6
\&{if} ${}(\|o,\39\\{vmem}[\\{thevar}(\|l)].\\{value}\AND{-}\T{2}){}$\1\5
${}\|o,\39\\{range}(\|c)\K\T{0},\39\\{asserts}\PP;{}$\2\6
\&{else}\1\5
\&{goto} \\{its\_true};\C{ true at root level }\2\6
\4${}\}{}$\5
\2\&{else}\5
${}\{{}$\1\6
\&{for} ${}(\|p\K\|q\K\T{0},\39\|k\K\|c+\\{size}(\|c)-\T{1};{}$ ${}\|k\G\|c;{}$
${}\|k\MM){}$\5
${}\{{}$\1\6
${}\\{oo},\39\|l\K\\{mem}[\|k].\\{lit},\39\|v\K\\{vmem}[\\{thevar}(\|l)].%
\\{value};{}$\6
\&{if} ${}(\|v<\T{2}){}$\5
${}\{{}$\C{ \PB{\|l} is defined at root level }\1\6
\&{if} ${}((\|v\XOR\|l)\AND\T{1}){}$\1\5
\&{continue};\C{ it's false, ignore it }\2\6
\4\\{its\_true}:\5
${}\|v\K\\{buckets}+\T{1}{}$;\5
${}\|o,\39\\{range}(\|c)\K\\{buckets}+\T{1};{}$\6
\&{goto} \\{range\_set};\C{ it's true, clause is superfluous }\6
\4${}\}{}$\5
\2\&{else}\5
${}\{{}$\1\6
\&{if} ${}(\|o,\39\\{levstamp}[(\|v\AND{-}\T{2})+\T{1}]<\|c){}$\1\5
${}\|o,\39\\{levstamp}[(\|v\AND{-}\T{2})+\T{1}]\K\|c,\39\|q\PP{}$;\C{ \PB{\|q}
here is called \PB{$\|p+\|q$} above }\2\6
\&{if} ${}(\\{levstamp}[(\|v\AND{-}\T{2})+\T{1}]\E\|c\W(((\|l\XOR\|v)\AND\T{1})%
\E\T{0}){}$)\C{ true literal }\1\6
${}\|o,\39\\{levstamp}[(\|v\AND{-}\T{2})+\T{1}]\K\|c+\T{1},\39\|p\PP;{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\|v\K(\&{int})((\\{buckets}/\\{badlevel})*{}$((\&{float}) \|p${}+\\{alpha}*(%
\&{float})(\|q-\|p)));{}$\6
\&{if} ${}(\|v\G\\{buckets}){}$\1\5
${}\|v\K\\{buckets}-\T{1};{}$\2\6
${}\|o,\39\\{range}(\|c)\K\|v;{}$\6
\&{if} ${}(\|v<\\{minrange}){}$\1\5
${}\\{minrange}\K\|v;{}$\2\6
\&{if} ${}(\|v>\\{maxrange}){}$\1\5
${}\\{maxrange}\K\|v;{}$\2\6
${}\\{oo},\39\\{rangedist}[\|v]\PP;{}$\6
\4${}\}{}$\2\6
\4\\{range\_set}:\5
;\6
\4${}\}{}$\2\par
\U112.\fi

\M{111}\B\X4:Global variables\X${}\mathrel+\E{}$\6
\&{int} ${}{*}\\{rangedist}{}$;\C{ how many clauses have a particular scaled
range? }\6
\&{int} \\{asserts};\C{ how many learned clauses are assertions that must
remain? }\6
\&{int} \\{minrange};\C{ the smallest scaled range we've seen on this round }\6
\&{int} \\{maxrange};\C{ the largest scaled range we've seen on this round }\6
\&{int} \\{recycle\_point};\C{ the first clause learned after the current full
run }\6
\&{int} \\{budget};\C{ the desired number of learned clauses after recycling }\6
\&{ullng} ${}{*}\\{clause\_heap}{}$;\C{ auxiliary array for partially sorting
clause activity }\6
\&{int} \\{clause\_heap\_size};\C{ its maximum size }\par
\fi

\M{112}Each clause recycling pass is a major event, something like spring
cleaning. First we prepare to compute the ranges by doing a full run,
so that every variable has been assigned to a level and a tentative
Boolean value. Then we backtrack to level zero, possibly learning
new clauses as we go. (Any such clauses \PB{\|c} will have \PB{$\|c\G\\{recycle%
\_point}$};
they have no range, so we treat them as if they were asserted,
with range~zero.) And then we drastically reduce our database of
learned clauses, using this opportunity to remove clauses that are
permanently satisfied and to remove literals that are permanently false.
During this process the watch lists need to be dismantled and rebuilt.

Notice that the second step in this process, backtracking to level zero,
is very much like doing a restart. (The only difference is that
``warmup'' rounds are automatically scheduled after every true restart.)
Thus the decisions that are taken at levels 1, 2, \dots\ will not necessarily
match the decisions that were in force at those levels when we decided to
do a recycling pass.

I don't think that is a bad thing. However, we could recreate those
decisions if we wanted to, by doing the following when backtracking
past a decision literal~\PB{\|l}: Set \PB{\|l}'s activity to the currently
largest
activity, which is the activity of the variable currently in \PB{\\{heap}[%
\T{0}]};
then bump it up, so that it becomes the new champion.

\Y\B\4\X112:Compute ranges for clause recycling\X${}\E{}$\6
$\\{recycle\_point}\K\\{max\_learned};{}$\6
${}\\{minrange}\K\\{buckets},\39\\{maxrange}\K\T{0};{}$\6
${}\\{asserts}\K\T{0};{}$\6
\&{for} ${}(\|k\K\T{0};{}$ ${}\|k<\\{vars};{}$ ${}\|k\PP){}$\1\5
${}\|o,\39\\{levstamp}[\|k+\|k+\T{1}]\K\T{0};{}$\2\6
\&{for} ${}(\|h\K\T{0},\39\|c\K\\{first\_learned};{}$ ${}\|c<\\{max%
\_learned};{}$ ${}\|h\PP,\39\|c\K\\{endc}+\\{learned\_extra}){}$\5
${}\{{}$\1\6
${}\|o,\39\\{endc}\K\|c+\\{size}(\|c);{}$\6
\X110:Compute the scaled range of \PB{\|c}\X;\6
\&{while} ${}(\|o,\39\\{mem}[\\{endc}].\\{lit}\AND\\{sign\_bit}){}$\1\5
${}\\{endc}\PP;{}$\2\6
\4${}\}{}$\2\6
${}\\{budget}\K\|h/\T{2};{}$\6
${}\\{prev\_learned}\K\T{0}{}$;\par
\U133.\fi

\M{113}\B\X113:Recycle half of the learned clauses\X${}\E{}$\6
\X114:Compress the database\X;\6
\X122:Recompute all the watch lists\X;\6
${}\\{recycle\_point}\K\T{0}{}$;\par
\U133.\fi

\M{114}\B\X114:Compress the database\X${}\E{}$\6
\&{for} ${}(\|o,\39\|j\K\\{minrange},\39\|s\K\\{asserts}+\\{rangedist}[\|j];{}$
${}\|s<\\{budget}\W\|j<\\{maxrange};{}$ \,)\1\5
${}\|o,\39\|s\MRL{+{\K}}\\{rangedist}[\PP\|j];{}$\2\6
\&{if} ${}(\|s>\\{budget}){}$\1\5
\X115:Remove \PB{$\|t\K\|s-\\{budget}$} clauses at the threshold\X;\2\6
\&{for} ${}(\|k\K\\{minrange}\GG\T{1};{}$ ${}\|k+\|k\Z\\{maxrange};{}$ ${}\|k%
\PP){}$\1\5
${}\|o,\39\\{rangedist}[\|k+\|k]\K\\{rangedist}[\|k+\|k+\T{1}]\K\T{0};{}$\2\6
\&{for} ${}(\|h\K\T{0},\39\\{cc}\K\|c\K\\{first\_learned};{}$ ${}\|c<\\{max%
\_learned};{}$ ${}\|c\K\\{endc}+\\{learned\_extra}){}$\5
${}\{{}$\1\6
${}\|o,\39\\{jj}\K\\{endc}\K\|c+\\{size}(\|c);{}$\6
\&{while} ${}(\|o,\39\\{mem}[\\{endc}].\\{lit}\AND\\{sign\_bit}){}$\1\5
${}\|o,\39\\{mem}[\\{endc}\PP].\\{lit}\K\T{0};{}$\2\6
\&{if} ${}(\|c<\\{recycle\_point}\W(\|o,\39\\{range}(\|c)>\|j)){}$\1\5
\&{continue};\C{ reject when the range is too high }\2\6
\&{for} ${}(\\{kk}\K\\{cc},\39\|k\K\|c;{}$ ${}\|k<\\{jj};{}$ ${}\|k\PP){}$\5
${}\{{}$\1\6
${}\|o,\39\|l\K\\{mem}[\|k].\\{lit};{}$\6
${}\|o,\39\|v\K\\{vmem}[\\{thevar}(\|l)].\\{value};{}$\6
\&{if} ((\&{uint}) \|v${}\I\\{unset}){}$\5
${}\{{}$\C{ \PB{\|l} has a permanent value at root level }\1\6
\&{if} ${}((\|v\XOR\|l)\AND\T{1}){}$\1\5
\&{continue};\C{ don't copy a permanently false literal }\2\6
\&{break};\C{ and don't copy a permanently satisfied clause }\6
\4${}\}{}$\5
\2\&{else}\1\5
${}\|o,\39\\{mem}[\\{kk}\PP].\\{lit}\K\|l{}$;\C{ but do copy otherwise }\2\6
\4${}\}{}$\2\6
\&{if} ${}(\|k<\\{jj}){}$\1\5
\&{continue};\C{ reject a satisfied clause }\2\6
${}\|h\PP{}$;\5
\X121:Wrap up clause \PB{\\{cc}}\X;\6
\4${}\}{}$\2\6
${}\\{max\_learned}\K\\{cc},\39\\{prev\_learned}\K\T{0};{}$\6
${}\|o,\39\\{mem}[\\{max\_learned}-\\{learned\_extra}].\\{lit}\K\T{0}{}$;\C{
put zero at end of \PB{\\{mem}} }\6
\&{if} ${}(\\{verbose}\AND(\\{show\_recycling}+\\{show\_recycling%
\_details})){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"\ (recycling\ reduced}\)\.{\ "}\|O\.{"d\
learned\ clauses\ t}\)\.{o\ "}\|O\.{"d)\\n"},\39\\{budget}*\T{2}+\T{1},\39%
\|h){}$;\C{ a little white lie sometimes }\2\par
\U113.\fi

\M{115}Clause activity scores are used only to break ties. So it's natural to
ask whether the effort of computing them and sorting through them is
actually worthwhile. Armin Biere has told me that a small but significant
number of problems do have a fairly large number of clauses at
the median range, so I'm following his recommendation.

\Y\B\4\X115:Remove \PB{$\|t\K\|s-\\{budget}$} clauses at the threshold\X${}%
\E{}$\6
${}\{{}$\1\6
\&{register} \&{ullng} \\{accum};\7
${}\|t\K\|s-\\{budget};{}$\6
${}\\{jj}\K\\{rangedist}[\|j]-\|t;{}$\6
\&{if} ${}(\\{jj}>\\{clause\_heap\_size}){}$\1\5
${}\\{jj}\K\\{clause\_heap\_size};{}$\2\6
\X117:Put \PB{\\{jj}} entries of range \PB{\|j} into the clause heap\X;\6
\X118:Establish heap order in the clause heap\X;\6
\X120:Increase the range of \PB{\|t} clauses from \PB{\|j} to \PB{$\|j+\T{1}$}%
\X;\6
\4${}\}{}$\2\par
\U114.\fi

\M{116}\B\X57:Allocate the auxiliary arrays\X${}\mathrel+\E{}$\6
$\\{clause\_heap\_size}\K\\{recycle\_bump}\GG\T{1};{}$\6
${}\\{clause\_heap}\K{}$(\&{ullng} ${}{*}){}$ \\{malloc}${}(\\{clause\_heap%
\_size}*\&{sizeof}(\&{ullng}));{}$\6
\&{if} ${}(\R\\{clause\_heap}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Oops,\ I\ can't\ alloc}\)\.{ate\ the\ clause%
\_heap\ }\)\.{array!\\n"});{}$\6
${}\\{exit}({-}\T{16});{}$\6
\4${}\}{}$\2\6
${}\\{bytes}\MRL{+{\K}}\\{clause\_heap\_size}*\&{sizeof}(\&{ullng}){}$;\par
\fi

\M{117}Entries of \PB{\\{clause\_heap}} are packed so that they sort on
activity first, location second. (If two clauses have equally
low activity, we prefer to forget the one that has had more
time to become active.)

We use the fact that nonnegative \PB{\&{float}} numbers can be compared
as if they were integers. Thus we interpret \PB{\\{active}(\|c)} as
a `\PB{\\{lit}}' instead of as a `\PB{\\{flt}}'.

\Y\B\4\X117:Put \PB{\\{jj}} entries of range \PB{\|j} into the clause heap\X${}%
\E{}$\6
\&{for} ${}(\|h\K\T{0},\39\|c\K\\{first\_learned};{}$ ${}\|h<\\{jj};{}$ ${}\|c%
\K\\{endc}+\\{learned\_extra}){}$\5
${}\{{}$\1\6
\&{if} ${}(\|c\G\\{recycle\_point}){}$\1\5
\\{confusion}(\.{"rangedist1"});\2\6
${}\|o,\39\\{endc}\K\|c+\\{size}(\|c);{}$\6
\&{while} ${}(\|o,\39\\{mem}[\\{endc}].\\{lit}\AND\\{sign\_bit}){}$\1\5
${}\\{endc}\PP;{}$\2\6
\&{if} ${}(\|o,\39\\{range}(\|c)\E\|j){}$\1\5
${}\\{clause\_heap}[\|h\PP]\K\\{activ\_as\_lit}(\|c)+\|c;{}$\2\6
\4${}\}{}$\2\par
\U115.\fi

\M{118}\B\X118:Establish heap order in the clause heap\X${}\E{}$\6
\&{for} ${}(\|h\K\\{jj}\GG\T{1};{}$ \|h; \,)\5
${}\{{}$\1\6
${}\|q\K\|h+\|h,\39\|p\K\MM\|h,\39\|o,\39\\{accum}\K\\{clause\_heap}[\|p];{}$\6
\X119:Sift \PB{\\{accum}} into the clause heap at \PB{\|p}\X;\6
\4${}\}{}$\2\par
\U115.\fi

\M{119}At this point \PB{$\|q\K\|p+\|p+\T{2}$}.

\Y\B\4\X119:Sift \PB{\\{accum}} into the clause heap at \PB{\|p}\X${}\E{}$\6
\&{while} ${}(\|q\Z\\{jj}){}$\5
${}\{{}$\1\6
\&{if} ${}(\|q\E\\{jj}\V(\\{oo},\39\\{clause\_heap}[\|q-\T{1}]<\\{clause%
\_heap}[\|q])){}$\1\5
${}\|q\MM;{}$\2\6
\&{if} ${}(\\{accum}\Z\\{clause\_heap}[\|q]){}$\1\5
\&{break};\C{ equality can't actually occur }\2\6
${}\|o,\39\\{clause\_heap}[\|p]\K\\{clause\_heap}[\|q];{}$\6
${}\|p\K\|q,\39\|q\K\|p+\|p+\T{2};{}$\6
\4${}\}{}$\2\6
${}\|o,\39\\{clause\_heap}[\|p]\K\\{accum}{}$;\par
\Us118\ET120.\fi

\M{120}We continue to pass over all learned clauses, looking for those
whose range is~\PB{\|j}, until \PB{\|t} more are found.

\Y\B\4\X120:Increase the range of \PB{\|t} clauses from \PB{\|j} to \PB{$\|j+%
\T{1}$}\X${}\E{}$\6
\&{for} ( ;  ; ${}\|c\K\\{endc}+\\{learned\_extra}){}$\5
${}\{{}$\1\6
\&{if} ${}(\|c\G\\{recycle\_point}){}$\1\5
\\{confusion}(\.{"rangedist2"});\2\6
\&{if} ${}(\|o,\39\\{range}(\|c)\E\|j){}$\5
${}\{{}$\1\6
${}\|o,\39\\{accum}\K\\{activ\_as\_lit}(\|c)+\|c;{}$\6
\&{if} ${}(\|o,\39\\{accum}<\\{clause\_heap}[\T{0}]){}$\5
${}\{{}$\1\6
${}\|o,\39\\{range}(\|c)\K\|j+\T{1};{}$\6
\&{if} ${}(\MM\|t\E\T{0}){}$\1\5
\&{break};\2\6
\4${}\}{}$\5
\2\&{else}\5
${}\{{}$\1\6
${}\|o,\39\\{range}((\&{int})(\\{clause\_heap}[\T{0}]\AND\T{\^ffffffff}))\K\|j+%
\T{1};{}$\6
\&{if} ${}(\MM\|t\E\T{0}){}$\1\5
\&{break};\2\6
${}\|p\K\T{0},\39\|q\K\T{2};{}$\6
\X119:Sift \PB{\\{accum}} into the clause heap at \PB{\|p}\X;\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\|o,\39\\{endc}\K\|c+\\{size}(\|c);{}$\6
\&{while} ${}(\|o,\39\\{mem}[\\{endc}].\\{lit}\AND\\{sign\_bit}){}$\1\5
${}\\{endc}\PP;{}$\2\6
\4${}\}{}$\2\par
\U115.\fi

\M{121}At this point we're operating at root level; that is, \PB{$\\{llevel}\K%
\T{0}$}.
And we've just copied the literals of a learned-clause-to-remember
into positions \PB{$\\{mem}[\\{cc}].\\{lit}$}, \PB{$\\{mem}[\\{cc}+\T{1}].%
\\{lit}$}, \dots,~\PB{$\\{mem}[\\{kk}-\T{1}].\\{lit}$}.

In rare circumstances the simplifications we've made might result in
a learned clause of size~1. Or even size~0!

\Y\B\4\X121:Wrap up clause \PB{\\{cc}}\X${}\E{}$\6
\&{if} ${}(\\{kk}\G\\{cc}+\T{2}){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{verbose}\AND\\{show\_recycling\_details}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"\ clause\ "}\|O\.{"d\ =\ recycled\ "}\|O\.{"d\
(size\ "}\|O\.{"d)\\n"},\39\\{cc},\39\|c,\39\\{kk}-\\{cc});{}$\2\6
${}\\{ooo},\39\\{size}(\\{cc})\K\\{kk}-\\{cc},\39\\{activ}(\\{cc})\K\\{activ}(%
\|c),\39\\{cc}\K\\{kk}+\\{learned\_extra};{}$\6
\4${}\}{}$\5
\2\&{else} \&{if} ${}(\\{kk}\E\\{cc}){}$\1\5
\&{goto} \\{unsat};\2\6
\&{else}\5
${}\{{}$\1\6
${}\|o,\39\|l\K\\{mem}[\\{cc}].\\{lit};{}$\6
${}\|o,\39\\{vmem}[\\{thevar}(\|l)].\\{value}\K\|l\AND\T{1},\39\\{vmem}[%
\\{thevar}(\|l)].\\{tloc}\K\\{eptr};{}$\6
${}\|o,\39\\{history}[\\{eptr}]\K\T{4},\39\\{trail}[\\{eptr}\PP]\K\|l;{}$\6
\&{if} ${}(\\{verbose}\AND(\\{show\_choices}+\\{show\_details}+\\{show%
\_recycling\_details})){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"\ level\ 0,\ "}\|O\.{"s"}\|O\.{".8s\ from\
recycled\ "}\|O\.{"d\\n"},\39\\{litname}(\|l),\39\|c);{}$\2\6
\4${}\}{}$\2\par
\U114.\fi

\M{122}\B\X122:Recompute all the watch lists\X${}\E{}$\6
\&{for} ${}(\|l\K\T{2};{}$ ${}\|l\Z\\{max\_lit};{}$ ${}\|l\PP){}$\1\5
${}\|o,\39\\{lmem}[\|l].\\{watch}\K\T{0};{}$\2\6
\&{for} ${}(\|c\K\\{clause\_extra};{}$ ${}\|c<\\{min\_learned};{}$ ${}\|c\K%
\\{endc}+\\{clause\_extra}){}$\5
${}\{{}$\1\6
${}\|o,\39\\{endc}\K\|c+\\{size}(\|c);{}$\6
\X123:Watch the first two literals of \PB{\|c}\X;\6
\&{while} ${}(\|o,\39\\{mem}[\\{endc}].\\{lit}\AND\\{sign\_bit}){}$\1\5
${}\\{endc}\PP{}$;\C{ necessary for \PB{$\|c<\\{min\_learned}$} }\2\6
\4${}\}{}$\2\6
\&{for} ${}(\|c\K\\{first\_learned};{}$ ${}\|c<\\{max\_learned};{}$ ${}\|c\K%
\\{endc}+\\{learned\_extra}){}$\5
${}\{{}$\1\6
${}\|o,\39\\{endc}\K\|c+\\{size}(\|c);{}$\6
\X123:Watch the first two literals of \PB{\|c}\X;\6
\4${}\}{}$\2\par
\U113.\fi

\M{123}A technicality for mem counting: We save one memory access either when
fetching \PB{$\\{mem}[\|c+\T{1}].\\{lit}$} or when storing into \PB{\\{link1}(%
\|c)}.

\Y\B\4\X123:Watch the first two literals of \PB{\|c}\X${}\E{}$\6
${}\{{}$\1\6
${}\|o,\39\|l\K\\{mem}[\|c].\\{lit};{}$\6
${}\\{ooo},\39\\{link0}(\|c)\K\\{lmem}[\|l].\\{watch},\39\\{lmem}[\|l].%
\\{watch}\K\|c;{}$\6
${}\|l\K\\{mem}[\|c+\T{1}].\\{lit};{}$\6
${}\\{ooo},\39\\{link1}(\|c)\K\\{lmem}[\|l].\\{watch},\39\\{lmem}[\|l].%
\\{watch}\K\|c;{}$\6
\4${}\}{}$\2\par
\U122.\fi

\N{1}{124}Putting it all together.
Most of the mechanisms that we need to solve a satisfiability problem
are now in place. We just need to set them in motion at the proper times.

\Y\B\4\X124:Solve the problem\X${}\E{}$\6
\X130:Finish the initialization\X;\6
\4\\{square\_one}:\5
${}\\{llevel}\K\\{warmup\_cycles}\K\T{0};{}$\6
\&{if} (\\{sanity\_checking})\1\5
\\{sanity}(\\{eptr});\2\6
\&{if} ${}(\\{verbose}\AND\\{show\_initial\_clauses}){}$\1\5
\\{print\_unsat}(\,);\2\6
${}\\{lptr}\K\T{0};{}$\6
\4\\{startup}:\5
${}\\{conflict\_level}\K\T{0};{}$\6
${}\\{full\_run}\K(\\{warmup\_cycles}<\\{warmups}\?\T{1}:\T{0});{}$\6
\4\\{proceed}:\5
${}\\{conflict\_seen}\K\T{0};{}$\6
\X127:Complete the current level, or \PB{\&{goto} \\{confl}}\X;\6
\4\\{newlevel}:\5
\&{if} (\\{sanity\_checking})\1\5
\\{sanity}(\\{eptr});\2\6
\&{if} ${}(\\{delta}\W(\\{mems}\G\\{thresh})){}$\1\5
${}\\{thresh}\MRL{+{\K}}\\{delta},\39\\{print\_state}(\\{eptr});{}$\2\6
\&{if} ${}(\\{mems}\G\\{timeout}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"TIMEOUT!\\n"}){}$;\5
\&{goto} \\{all\_done};\6
\4${}\}{}$\2\6
\&{if} ${}(\\{eptr}\E\\{vars}){}$\5
${}\{{}$\1\6
\&{if} ${}(\R\\{conflict\_level}){}$\1\5
\&{goto} \\{satisfied};\2\6
\X133:Finish a full run\X;\6
\&{goto} \\{startup};\6
\4${}\}{}$\2\6
\&{if} ${}(\R\\{conflict\_level}){}$\5
${}\{{}$\C{ no conflicting literals are on the trail }\1\6
\&{if} ${}(\\{total\_learned}\G\\{doomsday}){}$\1\5
\X138:Call it quits\X;\2\6
\&{if} ${}(\\{total\_learned}\G\\{next\_recycle}){}$\1\5
${}\\{full\_run}\K\T{1};{}$\2\6
\&{else} \&{if} ${}(\\{total\_learned}\G\\{next\_restart}){}$\1\5
\X136:Restart unless \PB{\\{agility}} is high\X;\2\6
\4${}\}{}$\2\6
${}\\{llevel}\MRL{+{\K}}\T{2};{}$\6
\X75:Choose the next decision literal, \PB{\|l}\X;\6
\&{if} ${}(\\{verbose}\AND\\{show\_choices}\W\\{llevel}\Z\\{show\_choices%
\_max}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"Level\ "}\|O\.{"d,\ trying\ "}\|O\.{"s"}\|O%
\.{".8s\ ("}\|O\.{"lld\ mems)\\n"},\39\\{llevel}\GG\T{1},\39\\{litname}(\|l),%
\39\\{mems});{}$\2\6
${}\\{depth\_per\_decision}\MRL{+{\K}}{-}(\\{depth\_per\_decision}\GG%
\T{7})+{}$((\&{ullng}) \\{llevel}${}\LL\T{24});{}$\6
${}\\{trail\_per\_decision}\MRL{+{\K}}{-}(\\{trail\_per\_decision}\GG%
\T{7})+{}$((\&{ullng}) \\{eptr}${}\LL\T{25});{}$\6
${}\|o,\39\\{lmem}[\|l].\\{reason}\K\T{0};{}$\6
${}\\{history}[\\{eptr}]\K\T{0};{}$\6
\4\\{launch}:\5
${}\\{nodes}\PP;{}$\6
${}\|o,\39\\{leveldat}[\\{llevel}]\K\\{eptr};{}$\6
${}\|o,\39\\{trail}[\\{eptr}\PP]\K\|l;{}$\6
${}\|o,\39\\{vmem}[\\{thevar}(\|l)].\\{tloc}\K\\{lptr}{}$;\C{ \PB{$\\{lptr}\K%
\\{eptr}-\T{1}$} }\6
${}\\{vmem}[\\{thevar}(\|l)].\\{value}\K\\{llevel}+(\|l\AND\T{1});{}$\6
${}\\{agility}\MRL{-{\K}}\\{agility}\GG\T{13}{}$;\C{ use the damping factor
$1-2^{-13}$ }\6
\&{goto} \\{proceed};\6
\X125:Resolve the current conflict\X;\par
\U2.\fi

\M{125}(I should mention somewhere that the updating of \PB{\\{agility}} here,
and elsewhere, has a known bug: Overflow from $2^{32}-1$ to $2^{32}$
is theoretically possible! However, this will certainly never occur
in practice; and even if it does, it will cause no great harm.)

\Y\B\4\X125:Resolve the current conflict\X${}\E{}$\6
\4\\{confl}:\5
\&{if} (\\{llevel})\5
${}\{{}$\1\6
\4\\{prep\_clause}:\5
\X86:Deal with the conflict clause \PB{\|c}\X;\6
\X102:Simplify the learned clause\X;\C{ Note: \PB{\\{lll}} is the false literal
that will become true }\6
\&{if} (\\{full\_run})\1\5
\&{goto} \\{store\_clause};\2\6
${}\\{decisionvar}\K(\\{lmem}[\\{bar}(\\{lll})].\\{reason}\?\T{0}:\T{1}){}$;\C{
was it first in its level? }\6
\X128:Backtrack to \PB{\\{jumplev}}\X;\6
\&{if} ${}(\\{learned\_size}>\T{1}){}$\5
${}\{{}$\1\6
\X103:Learn the simplified clause\X\6
\&{if} ${}(\\{verbose}\AND(\\{show\_details}+\\{show\_choices})){}$\5
${}\{{}$\1\6
\&{if} ${}((\\{verbose}\AND\\{show\_details})\V\\{llevel}\Z\\{show\_choices%
\_max}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"level\ "}\|O\.{"d,\ "}\|O\.{"s"}\|O\.{".8s\
from\ "}\|O\.{"d\\n"},\39\\{llevel}\GG\T{1},\39\\{litname}(\\{lll}),\39\|c);{}$%
\2\6
\4${}\}{}$\2\6
${}\|o,\39\\{lmem}[\\{lll}].\\{reason}\K\|c;{}$\6
\4${}\}{}$\5
\2\&{else}\1\5
\X126:Learn a clause of size 1\X;\2\6
${}\|o,\39\\{vmem}[\\{thevar}(\\{lll})].\\{value}\K\\{llevel}+(\\{lll}\AND%
\T{1}),\39\\{vmem}[\\{thevar}(\\{lll})].\\{tloc}\K\\{eptr};{}$\6
${}\\{history}[\\{eptr}]\K(\\{decisionvar}\?\T{2}:\T{6});{}$\6
${}\|o,\39\\{trail}[\\{eptr}\PP]\K\\{lll};{}$\6
${}\\{agility}\MRL{-{\K}}\\{agility}\GG\T{13}{}$;\C{ use the damping factor
$1-2^{-13}$ }\6
${}\\{agility}\MRL{+{\K}}\T{1}\LL\T{19}{}$;\C{ ``bug'' }\6
\X82:Bump the bumps\X;\6
\&{if} (\\{sanity\_checking})\1\5
\\{sanity}(\\{eptr});\2\6
\&{goto} \\{proceed};\6
\4${}\}{}$\2\6
\4\\{unsat}:\5
\&{if} (\T{1})\5
${}\{{}$\1\6
\\{printf}(\.{"\~\\n"});\C{ the formula was unsatisfiable }\6
\&{if} ${}(\\{verbose}\AND\\{show\_basics}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"UNSAT\\n"});{}$\2\6
\4${}\}{}$\5
\2\&{else}\5
${}\{{}$\1\6
\4\\{satisfied}:\5
\&{if} ${}(\\{verbose}\AND\\{show\_basics}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"!SAT!\\n"});{}$\2\6
\X129:Print the solution found\X;\6
\4${}\}{}$\2\par
\U124.\fi

\M{126}\B\X126:Learn a clause of size 1\X${}\E{}$\6
${}\{{}$\1\6
\&{if} ${}(\\{verbose}\AND(\\{show\_details}+\\{show\_choices})){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"level\ 0,\ learned\ "}\|O\.{"s"}\|O\.{".8s%
\\n"},\39\\{litname}(\\{lll}));{}$\2\6
\&{if} (\\{learned\_file})\5
${}\{{}$\1\6
${}\\{fprintf}(\\{learned\_file},\39\.{"\ "}\|O\.{"s"}\|O\.{".8s\\n"},\39%
\\{litname}(\\{lll}));{}$\6
\\{fflush}(\\{learned\_file});\6
${}\\{learned\_out}\PP;{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U125.\fi

\M{127}\B\X127:Complete the current level, or \PB{\&{goto} \\{confl}}\X${}\E{}$%
\6
$\\{ebptr}\K\\{eptr}{}$;\C{ binary implications needn't be checked after this
point }\6
\&{while} ${}(\\{lptr}<\\{eptr}){}$\5
${}\{{}$\1\6
${}\|o,\39\\{lt}\K\\{trail}[\\{lptr}\PP];{}$\6
\&{if} ${}(\\{lptr}\Z\\{ebptr}){}$\5
${}\{{}$\1\6
${}\|o,\39\\{lat}\K\\{lmem}[\\{lt}].\\{bimp\_end};{}$\6
\&{if} (\\{lat})\5
${}\{{}$\1\6
${}\|l\K\\{lt};{}$\6
\X58:Propagate binary implications of \PB{\|l}; \PB{\&{goto} \\{confl}} if a
conflict arises\X;\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\X60:Propagate nonbinary implications of \PB{\\{lt}}; \PB{\&{goto} \\{confl}}
if there's a conflict\X;\6
\4${}\}{}$\2\par
\U124.\fi

\M{128}\B\X128:Backtrack to \PB{\\{jumplev}}\X${}\E{}$\6
${}\{{}$\1\6
${}\|o,\39\|k\K\\{leveldat}[\\{jumplev}+\T{2}];{}$\6
\&{while} ${}(\\{eptr}>\|k){}$\5
${}\{{}$\1\6
${}\|o,\39\|l\K\\{trail}[\MM\\{eptr}],\39\|v\K\\{thevar}(\|l);{}$\6
${}\\{oo},\39\\{vmem}[\|v].\\{oldval}\K\\{vmem}[\|v].\\{value};{}$\6
${}\|o,\39\\{vmem}[\|v].\\{value}\K\\{unset};{}$\6
${}\|o,\39\\{lmem}[\|l].\\{reason}\K\T{0};{}$\6
\&{if} ${}(\\{eptr}<\\{lptr}\W(\|o,\39\\{vmem}[\|v].\\{hloc}<\T{0})){}$\1\5
\X74:Put \PB{\|v} into the heap\X;\2\6
\4${}\}{}$\2\6
${}\\{lptr}\K\\{eptr};{}$\6
\&{if} (\\{sanity\_checking})\5
${}\{{}$\1\6
\&{while} ${}(\\{llevel}>\\{jumplev}){}$\1\5
${}\\{leveldat}[\\{llevel}]\K{-}\T{1},\39\\{llevel}\MRL{-{\K}}\T{2};{}$\2\6
\4${}\}{}$\5
\2\&{else}\1\5
${}\\{llevel}\K\\{jumplev};{}$\2\6
\4${}\}{}$\2\par
\Us125, 133, 134\ETs137.\fi

\M{129}\B\X129:Print the solution found\X${}\E{}$\6
\&{for} ${}(\|k\K\T{0};{}$ ${}\|k<\\{vars};{}$ ${}\|k\PP){}$\5
${}\{{}$\1\6
${}\|o,\39\\{printf}(\.{"\ "}\|O\.{"s"}\|O\.{".8s"},\39\\{litname}(\\{trail}[%
\|k]));{}$\6
\4${}\}{}$\2\6
\\{printf}(\.{"\\n"});\6
\&{if} (\\{out\_file})\5
${}\{{}$\1\6
\&{for} ${}(\|k\K\T{0};{}$ ${}\|k<\\{vars};{}$ ${}\|k\PP){}$\5
${}\{{}$\1\6
${}\|o,\39\\{fprintf}(\\{out\_file},\39\.{"\ "}\|O\.{"s"}\|O\.{".8s"},\39%
\\{litname}(\\{bar}(\\{trail}[\|k])));{}$\6
\4${}\}{}$\2\6
${}\\{fprintf}(\\{out\_file},\39\.{"\\n"});{}$\6
${}\\{fprintf}(\\{stderr},\39\.{"Solution-avoiding\ c}\)\.{lause\ written\ to\
fil}\)\.{e\ `"}\|O\.{"s'.\\n"},\39\\{out\_name});{}$\6
\4${}\}{}$\2\par
\U125.\fi

\M{130}\B\X130:Finish the initialization\X${}\E{}$\6
\&{if} ${}(\\{rand\_prob}\G\T{1.0}){}$\1\5
${}\\{rand\_prob\_thresh}\K\T{\^80000000};{}$\2\6
\&{else}\1\5
${}\\{rand\_prob\_thresh}\K(\&{int})(\\{rand\_prob}*\T{2147483648.0});{}$\2\6
${}\\{var\_bump\_factor}\K\T{1.0}/{}$(\&{double}) \\{var\_rho};\6
${}\\{clause\_bump\_factor}\K\T{1.0}/\\{clause\_rho};{}$\6
${}\\{show\_choices\_max}\MRL{{\LL}{\K}}\T{1}{}$;\C{ double the level-oriented
parameters }\6
${}\\{next\_recycle}\K\\{recycle\_bump};{}$\6
\&{if} ${}(\\{next\_recycle}>\\{doomsday}){}$\1\5
${}\\{next\_recycle}\K\\{doomsday};{}$\2\6
${}\\{restart\_psi}\K\\{two\_to\_the\_32}*{}$(\&{double}) \\{restart\_psi%
\_fraction};\6
${}\\{restart\_u}\K\\{restart\_v}\K\\{next\_restart}\K\T{1};{}$\6
\&{if} ${}(\\{verbose}\AND\\{show\_details}){}$\5
${}\{{}$\1\6
\&{for} ${}(\|k\K\T{0};{}$ ${}\|k<\\{eptr};{}$ ${}\|k\PP){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{""}\|O\.{"s"}\|O\.{".8s\ is\ given\\n"},\39%
\\{litname}(\\{trail}[\|k]));{}$\2\6
\4${}\}{}$\2\6
\&{for} ${}(\|k\K\T{0};{}$ ${}\|k<\\{vars};{}$ ${}\|k\PP){}$\1\5
${}\|o,\39\\{leveldat}[\|k+\|k]\K{-}\T{1},\39\\{leveldat}[\|k+\|k+\T{1}]\K%
\T{0}{}$;\2\par
\U124.\fi

\M{131}\B\X131:Schedule the next restart\X${}\E{}$\6
\&{if} ${}((\\{restart\_u}\AND{-}\\{restart\_u})\E\\{restart\_v}){}$\1\5
${}\\{restart\_u}\PP,\39\\{restart\_v}\K\T{1},\39\\{restart\_thresh}\K%
\\{restart\_psi};{}$\2\6
\&{else}\1\5
${}\\{restart\_v}\MRL{{\LL}{\K}}\T{1},\39\\{restart\_thresh}\MRL{+{\K}}%
\\{restart\_thresh}\GG\T{4};{}$\2\6
${}\\{next\_restart}\K\\{total\_learned}+\\{restart\_v};{}$\6
\&{if} ${}(\\{next\_restart}>\\{doomsday}){}$\1\5
${}\\{next\_restart}\K\\{doomsday}{}$;\2\par
\U136.\fi

\M{132}\B\X132:Schedule the next recycling pass\X${}\E{}$\6
$\\{recycle\_bump}\MRL{+{\K}}\\{recycle\_inc};{}$\6
${}\\{next\_recycle}\K\\{total\_learned}+\\{recycle\_bump};{}$\6
\&{if} ${}(\\{next\_recycle}>\\{doomsday}){}$\1\5
${}\\{next\_recycle}\K\\{doomsday}{}$;\2\par
\U133.\fi

\M{133}After a full cycle has assigned values to all the variables,
we go back and learn clauses from each of the recorded conflicts.

If clause $c_i$ is learned at level $l_i$, it tells us that some literal~$u_i$
that was set false at~$l_i$ can now be set to true at some previous level
$l'_i<l_i$. We want to backtrack to the minimum of those levels $l'_i$, which
we'll call \PB{\\{minjumplev}}.

\Y\B\4\X133:Finish a full run\X${}\E{}$\6
\&{if} ${}(\\{total\_learned}\G\\{next\_recycle}){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{verbose}\AND(\\{show\_details}+\\{show\_gory\_details}+\\{show%
\_recycling}+\\{show\_recycling\_details})){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"Preparing\ to\ recycl}\)\.{e\ ("}\|O\.{"llu\
conflicts,\ "}\|O\.{"llu\ mems)\\n"},\39\\{total\_learned},\39\\{mems});{}$\2\6
\X112:Compute ranges for clause recycling\X;\6
\4${}\}{}$\5
\2\&{else}\5
${}\{{}$\1\6
${}\\{warmup\_cycles}\PP;{}$\6
\&{if} ${}(\\{verbose}\AND(\\{show\_choices}+\\{show\_details}+\\{show\_gory%
\_details}+\\{show\_warmlearn})){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"Finishing\ warmup\ ro}\)\.{und\ "}\|O\.{"d:%
\\n"},\39\\{warmup\_cycles});{}$\2\6
\4${}\}{}$\2\6
${}\|o,\39\\{leveldat}[\\{llevel}+\T{2}]\K\\{eptr};{}$\6
${}\\{minjumplev}\K\\{max\_lit}{}$;\C{ an ``infinite'' level }\6
\&{for} ( ; \\{conflict\_level}; \,)\1\5
\X134:Learn from the conflict at \PB{\\{conflict\_level}}\X;\2\6
\&{if} (\\{recycle\_point})\1\5
${}\\{jumplev}\K\T{0};{}$\2\6
\&{else}\1\5
${}\\{jumplev}\K\\{minjumplev};{}$\2\6
\X128:Backtrack to \PB{\\{jumplev}}\X;\6
${}\\{trail\_marker}\K\\{eptr};{}$\6
\&{if} ${}(\\{jumplev}\E\\{minjumplev}){}$\1\5
\X135:Place the literals learned at \PB{\\{minjumplev}} at the end of the trail%
\X;\2\6
\X82:Bump the bumps\X;\6
\&{if} (\\{recycle\_point})\5
${}\{{}$\1\6
\X113:Recycle half of the learned clauses\X;\6
\&{if} (\\{sanity\_checking})\1\5
\\{sanity}(\\{eptr});\2\6
\X132:Schedule the next recycling pass\X;\6
\4${}\}{}$\2\par
\U124.\fi

\M{134}Trivial clauses that arise during a full run are ignored, unless they
are
on the first conflict level, because they are never applicable
at higher levels.

Several different literals $u_i$ might all turn to be learned at
\PB{\\{minjumplev}}. Therefore we keep track of them on a stack within the
\PB{\\{conflictdat}} array. The top item on this stack is accessed via \PB{%
\\{next\_learned}}.

\Y\B\4\X134:Learn from the conflict at \PB{\\{conflict\_level}}\X${}\E{}$\6
${}\{{}$\1\6
${}\|o,\39\\{jumplev}\K\\{conflict\_level},\39\\{conflict\_level}\K%
\\{conflictdat}[\\{conflict\_level}];{}$\6
\X128:Backtrack to \PB{\\{jumplev}}\X;\6
${}\|o,\39\|c\K\\{leveldat}[\\{llevel}+\T{1}];{}$\6
\&{if} ${}(\|c<\T{0}){}$\1\5
${}\|o,\39\|l\K{-}\|c,\39\\{ll}\K\\{conflictdat}[\\{llevel}+\T{1}];{}$\2\6
\&{goto} \\{prep\_clause};\6
\4\\{store\_clause}:\5
\C{ apology: these \PB{\&{goto}}'s are because of \PB{\&{goto}}'s in
simplification }\C{ now \PB{\\{lll}} is a false literal that will become true
at \PB{\\{jumplev}} }\6
\&{if} ${}(\\{trivial\_learning}\W\\{conflict\_level}){}$\5
${}\{{}$\1\6
${}\\{cells\_prelearned}\MRL{-{\K}}\\{prelearned\_size};{}$\6
${}\\{cells\_learned}\MRL{-{\K}}\\{learned\_size},\39\\{total\_learned}\MM,\39%
\\{trivials}\MM;{}$\6
\4${}\}{}$\5
\2\&{else}\5
${}\{{}$\1\6
\&{if} ${}(\\{jumplev}\Z\\{minjumplev}){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{jumplev}<\\{minjumplev}){}$\1\5
${}\\{minjumplev}\K\\{jumplev},\39\\{next\_learned}\K\T{0};{}$\2\6
${}\|o,\39\\{conflictdat}[\\{llevel}]\K\\{next\_learned},\39\\{conflictdat}[%
\\{llevel}+\T{1}]\K\\{lll};{}$\6
${}\\{next\_learned}\K\\{llevel};{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{learned\_size}\E\T{1}){}$\5
${}\{{}$\1\6
${}\|o,\39\\{leveldat}[\\{llevel}+\T{1}]\K\T{0};{}$\6
\&{if} (\\{learned\_file})\5
${}\{{}$\1\6
${}\\{fprintf}(\\{learned\_file},\39\.{"\ "}\|O\.{"s"}\|O\.{".8s\\n"},\39%
\\{litname}(\\{lll}));{}$\6
\\{fflush}(\\{learned\_file});\6
${}\\{learned\_out}\PP;{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{verbose}\AND\\{show\_warmlearn}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"(learned\ unit\ claus}\)\.{e\ "}\|O\.{"s"}\|O%
\.{".8s)\\n"},\39\\{litname}(\\{lll}));{}$\2\6
\4${}\}{}$\5
\2\&{else}\5
${}\{{}$\1\6
\X103:Learn the simplified clause\X;\6
${}\|o,\39\\{leveldat}[\\{llevel}+\T{1}]\K\|c;{}$\6
\&{if} ${}(\\{verbose}\AND\\{show\_warmlearn}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"(learned\ clause\ "}\|O\.{"d\ of\ size\ "}\|O%
\.{"d)\\n"},\39\|c,\39\\{learned\_size});{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U133.\fi

\M{135}\B\X135:Place the literals learned at \PB{\\{minjumplev}} at the end of
the trail\X${}\E{}$\6
\&{while} (\\{next\_learned})\5
${}\{{}$\1\6
${}\|o,\39\\{lll}\K\\{conflictdat}[\\{next\_learned}+\T{1}];{}$\6
${}\|o,\39\|c\K\\{leveldat}[\\{next\_learned}+\T{1}];{}$\6
${}\\{next\_learned}\K\\{conflictdat}[\\{next\_learned}];{}$\6
\&{if} ${}(\\{verbose}\AND(\\{show\_details}+\\{show\_choices})){}$\5
${}\{{}$\1\6
\&{if} ${}((\\{verbose}\AND\\{show\_details})\V\\{llevel}\Z\\{show\_choices%
\_max}){}$\5
${}\{{}$\1\6
\&{if} (\|c)\1\5
${}\\{fprintf}(\\{stderr},\39\.{"level\ "}\|O\.{"d,\ "}\|O\.{"s"}\|O\.{".8s\
from\ "}\|O\.{"d\\n"},\39\\{llevel}\GG\T{1},\39\\{litname}(\\{lll}),\39\|c);{}$%
\2\6
\&{else}\1\5
${}\\{fprintf}(\\{stderr},\39\.{"level\ 0,\ "}\|O\.{"s"}\|O\.{".8s\\n"},\39%
\\{litname}(\\{lll}));{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\|o,\39\\{vmem}[\\{thevar}(\\{lll})].\\{value}\K\\{llevel}+(\\{lll}\AND%
\T{1}),\39\\{vmem}[\\{thevar}(\\{lll})].\\{tloc}\K\\{eptr};{}$\6
${}\|o,\39\\{lmem}[\\{lll}].\\{reason}\K\|c;{}$\6
${}\|o,\39\\{history}[\\{eptr}]\K\T{4},\39\\{trail}[\\{eptr}\PP]\K\\{lll};{}$\6
\4${}\}{}$\2\par
\U133.\fi

\M{136}Following the advice of Armin Biere [{\sl Lecture Notes in Computer
Science\/ \bf4996} (2008), 28--33], I disable restarts when there's lots
of agility (recent flips of variables). The threshold is higher when
the time to next restart is longer.

\Y\B\4\X136:Restart unless \PB{\\{agility}} is high\X${}\E{}$\6
${}\{{}$\1\6
\X131:Schedule the next restart\X;\6
\&{if} ${}(\\{agility}\Z\\{restart\_thresh}){}$\1\5
\X137:Flush literals\X\2\6
\&{else} \&{if} ${}(\\{verbose}\AND\\{show\_restarts}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"No\ restart\ ("}\|O\.{"llu\ conflicts,\ "}\|O%
\.{"llu\ mems,\ agility\ "}\|O\.{".2f)\\n"},\39\\{total\_learned},\39\\{mems},%
\39{}$(\&{double}) \\{agility}${}/\\{two\_to\_the\_32});{}$\2\6
\4${}\}{}$\2\par
\U124.\fi

\M{137}Instead of restarting completely, by backing up all the way to level~0,
we follow the advice of van~der~Tak, Ramos, and Heule [{\sl Journal
on Satisfiability, Boolean Modeling and Computation\/ \bf7} (2011), 133--138]:
We return to the first level for which a new variable will be injected into
the trail. (That new variable will be the one with maximum activity, among all
that are currently unset.) Sometimes that will not require backtracking at all.

(I've lately decided to call this ``flushing,'' not ``restarting,'' in my
book.)

\Y\B\4\X137:Flush literals\X${}\E{}$\6
${}\{{}$\1\6
${}\\{actual\_restarts}\PP;{}$\6
\&{if} ${}(\\{verbose}\AND(\\{show\_details}+\\{show\_choices}+\\{show%
\_restarts})){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"Restarting\ ("}\|O\.{"llu\ conflicts,\ "}\|O%
\.{"llu\ mems,\ agility\ "}\|O\.{".2f)\\n"},\39\\{total\_learned},\39\\{mems},%
\39{}$(\&{double}) \\{agility}${}/\\{two\_to\_the\_32});{}$\2\6
\&{if} (\\{llevel})\5
${}\{{}$\1\6
\&{while} (\T{1})\5
${}\{{}$\1\6
${}\|o,\39\|v\K\\{heap}[\T{0}];{}$\6
\&{if} ${}(\|o,\39\\{vmem}[\|v].\\{value}\E\\{unset}){}$\1\5
\&{break};\2\6
\X77:Delete \PB{\|v} from the heap\X;\6
\4${}\}{}$\2\6
${}\|o,\39\\{av}\K\\{vmem}[\|v].\\{activity};{}$\6
\&{for} ${}(\\{jumplev}\K\T{0};{}$ ${}\\{jumplev}<\\{llevel};{}$ ${}\\{jumplev}%
\MRL{+{\K}}\T{2}){}$\5
${}\{{}$\1\6
${}\\{oo},\39\|v\K\\{thevar}(\\{trail}[\\{leveldat}[\\{jumplev}+\T{2}]]){}$;\C{
a decision variable }\6
\&{if} ${}(\|o,\39\\{vmem}[\|v].\\{activity}<\\{av}){}$\1\5
\&{break};\C{ new guy will replace \PB{\|v} }\2\6
\4${}\}{}$\2\6
\&{if} ${}(\\{jumplev}<\\{llevel}){}$\1\5
\X128:Backtrack to \PB{\\{jumplev}}\X;\2\6
\4${}\}{}$\2\6
${}\\{trail\_marker}\K\\{eptr};{}$\6
${}\\{warmup\_cycles}\K\T{0};{}$\6
\&{goto} \\{startup};\6
\4${}\}{}$\2\par
\U136.\fi

\M{138}Well, we didn't solve the problem. Too bad. At least we can report
what progress was made.

\Y\B\4\X138:Call it quits\X${}\E{}$\6
${}\{{}$\1\6
\&{if} ${}(\\{verbose}\AND\\{show\_basics}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"Timeout:\ Terminatin}\)\.{g\ an\ incomplete\
run\ }\)\.{(level\ "}\|O\.{"d).\\n"},\39\\{llevel}\GG\T{1});{}$\2\6
\\{print\_state}(\\{eptr});\6
\&{if} (\\{polarity\_outfile})\5
${}\{{}$\1\6
\&{for} ${}(\|k\K\T{0};{}$ ${}\|k<\\{eptr};{}$ ${}\|k\PP){}$\5
${}\{{}$\1\6
${}\|o,\39\|l\K\\{trail}[\|k];{}$\6
${}\\{fprintf}(\\{polarity\_outfile},\39\.{"\ "}\|O\.{"s"}\|O\.{".8s"},\39%
\\{litname}(\|l));{}$\6
${}\|o,\39\\{vmem}[\\{thevar}(\|l)].\\{oldval}\K\\{unset};{}$\6
\4${}\}{}$\2\6
${}\\{fprintf}(\\{polarity\_outfile},\39\.{"\\n"});{}$\6
\&{for} ${}(\|v\K\T{1};{}$ ${}\|v\Z\\{vars};{}$ ${}\|v\PP){}$\1\6
\&{if} ${}(\|o,\39\\{vmem}[\|v].\\{oldval}\I\\{unset}){}$\1\5
${}\\{fprintf}(\\{polarity\_outfile},\39\.{""}\|O\.{"s"}\|O\.{".8s\\n"},\39%
\\{vmem}[\|v].\\{oldval}\AND\T{1}\?\.{"\~"}:\.{""},\39\\{vmem}[\|v].\\{name}.%
\\{ch8});{}$\2\2\6
${}\\{fprintf}(\\{stderr},\39\.{"Polarity\ data\ writt}\)\.{en\ to\ file\ `"}%
\|O\.{"s'.\\n"},\39\\{polarity\_out\_name});{}$\6
\4${}\}{}$\2\6
\&{if} (\\{restart\_file})\5
${}\{{}$\1\6
\&{for} ${}(\|o,\39\|k\K\T{0};{}$ ${}\|k<\\{leveldat}[\T{2}];{}$ ${}\|k\PP{}$)%
\C{ print unit clauses learned }\1\6
${}\|o,\39\\{fprintf}(\\{restart\_file},\39\.{"\ "}\|O\.{"s"}\|O\.{".8s\\n"},%
\39\\{litname}(\\{trail}[\|k]));{}$\2\6
\&{for} ${}(\|c\K\\{first\_learned};{}$ ${}\|c<\\{max\_learned};{}$ ${}\|c\K%
\\{kk}+\\{learned\_extra}){}$\5
${}\{{}$\1\6
\&{for} ${}(\|o,\39\|k\K\|c,\39\\{kk}\K\|c+\\{size}(\|c);{}$ ${}\|k<\\{kk};{}$
${}\|k\PP){}$\1\5
${}\|o,\39\\{fprintf}(\\{restart\_file},\39\.{"\ "}\|O\.{"s"}\|O\.{".8s"},\39%
\\{litname}(\\{mem}[\|k].\\{lit}));{}$\2\6
${}\\{fprintf}(\\{restart\_file},\39\.{"\\n"});{}$\6
\4${}\}{}$\2\6
${}\\{fprintf}(\\{stderr},\39\.{"Current\ learned\ cla}\)\.{uses\ written\ to\
file}\)\.{\ `"}\|O\.{"s'.\\n"},\39\\{restart\_name});{}$\6
\4${}\}{}$\2\6
\&{goto} \\{all\_done};\6
\4${}\}{}$\2\par
\U124.\fi

\M{139}\B\X139:Debugging fallbacks\X${}\E{}$\6
\&{void} \\{confusion}(\&{char} ${}{*}\\{id}){}$\1\1\2\2\6
${}\{{}$\C{ an assertion has failed }\1\6
${}\\{fprintf}(\\{stderr},\39\.{"This\ can't\ happen\ (}\)\.{"}\|O\.{"s)!\\n"},%
\39\\{id});{}$\6
${}\\{exit}({-}\T{666});{}$\6
\4${}\}{}$\2\7
\&{void} \\{debugstop}(\&{int} \\{foo})\1\1\2\2\6
${}\{{}$\C{ can be inserted as a special breakpoint }\1\6
${}\\{fprintf}(\\{stderr},\39\.{"You\ rang("}\|O\.{"d)?\\n"},\39\\{foo});{}$\6
\4${}\}{}$\2\par
\U2.\fi

\M{140}\B\X4:Global variables\X${}\mathrel+\E{}$\6
\&{int} \\{full\_run};\C{ are we making a pass to gather data on all variables?
}\6
\&{int} \\{conflict\_seen};\C{ have we seen a conflict at the current level? }\6
\&{int} \\{decisionvar};\C{ does the learned clause involve the decision
literal? }\6
\&{int} \\{prev\_learned};\C{ number of the clause most recently learned }\6
\&{int} \\{warmup\_cycles};\C{ this many warmups have been done since restart }%
\6
\&{int} \\{next\_learned};\C{ top of stack of literals learned at \PB{%
\\{minjumplev}} }\6
\&{int} \\{restart\_u}${},{}$ \\{restart\_v};\C{ generators for the reluctant
doubling sequence }\6
\&{ullng} \\{restart\_thresh};\C{ agility threshold for restarting }\6
\&{int} \\{trail\_marker};\C{ position of the latest restart or full run pass }%
\6
\&{int} \\{minjumplev};\C{ level to which we'll return after a full run }\par
\fi

\N{1}{141}Index.
\fi

\inx
\fin
\con
