\input cwebmac
% (c) 2005 D E Knuth; use and enjoy, but please don't blame me for mistakes...
\datethis
\def\title{FRAN\c{C}ON}


\N{1}{1}Introduction. This short program implements a Fran\c{c}on-inspired
bijection between binary trees with Strahler number~$s$
and nested strings with height~$h$, where $2^s-1\le h<2^{s+1}-1$.
But it uses a direct method that is complementary to his approach.
[Reference: Jean Fran\c{c}on, ``Sur le nombre de registres n\'ecessaires
a l'\'evaluation d'une expression arithm\'etique,'' {\sl R.A.I.R.O.
Informatique th\'eorique\/ \bf18} (1984), 355--364.]

\Y\B\4\D$\|n$ \5
\T{17}\C{ nodes in the tree }\par
\B\4\D$\\{nn}$ \5
$(\|n+\|n{}$)\par
\Y\B\8\#\&{include} \.{<stdio.h>}\6
\&{int} ${}\|d[\\{nn}+\T{1}]{}$;\C{ the path, a sequence of $\pm1$s }\6
\&{int} ${}\|l[\|n+\T{1}],{}$ ${}\|r[\|n+\T{1}]{}$;\C{ tree links }\6
\&{int} ${}\|h[\\{nn}+\T{1}],{}$ ${}\|q[\|n+\T{1}],{}$ ${}\\{qm}[\|n+\T{1}]{}$;%
\C{ heap and queue structures for decision-making }\6
\&{int} \\{serial};\C{ total number of cases checked }\6
\&{int} \\{count}[\T{10}];\C{ individual counts by Strahler number }\7
\X5:Subroutines\X\7
\\{main}(\,)\1\1\2\2\6
${}\{{}$\1\6
\&{register} \&{int} \|i${},{}$ \|j${},{}$ \|k${},{}$ \\{jj}${},{}$ %
\\{kk}${},{}$ \|m${},{}$ \|p${},{}$ \|s;\7
${}\\{printf}(\.{"Checking\ binary\ tre}\)\.{es\ with\ \%d\ nodes...\\}\)%
\.{n"},\39\|n);{}$\6
\X2:Set up the first nested string, \PB{\|d}\X;\6
\&{while} (\T{1})\5
${}\{{}$\1\6
\X7:Find the tree corresponding to \PB{\|d}\X;\6
\X4:Check the Strahler number\X;\6
\X9:Check the inverse bijection\X;\6
\X3:Move to the next nested string, or \PB{\&{goto} \\{done}}\X;\6
\4${}\}{}$\2\6
\4\\{done}:\6
\&{for} ${}(\|s\K\T{1};{}$ \\{count}[\|s]; ${}\|s\PP){}$\1\5
${}\\{printf}(\.{"Altogether\ \%d\ cases}\)\.{\ with\ Strahler\ numbe}\)\.{r\ %
\%d.\\n"},\39\\{count}[\|s],\39\|s);{}$\2\6
\4${}\}{}$\2\par
\fi

\M{2}Nested strings (aka Dyck words) are conveniently generated by
Algorithm 7.2.1.6P of {\sl The Art of Computer Programming}.

\Y\B\4\X2:Set up the first nested string, \PB{\|d}\X${}\E{}$\6
\&{for} ${}(\|k\K\T{0};{}$ ${}\|k<\\{nn};{}$ ${}\|k\MRL{+{\K}}\T{2}){}$\1\5
${}\|d[\|k]\K{+}\T{1},\39\|d[\|k+\T{1}]\K{-}\T{1};{}$\2\6
${}\|d[\\{nn}]\K{-}\T{1},\39\|i\K\\{nn}-\T{2}{}$;\par
\U1.\fi

\M{3}At this point, variable \PB{\|i} is the position of the rightmost `$+1$'
in \PB{\|d}.

\Y\B\4\X3:Move to the next nested string, or \PB{\&{goto} \\{done}}\X${}\E{}$\6
$\|d[\|i]\K{-}\T{1};{}$\6
\&{if} ${}(\|d[\|i-\T{1}]<\T{0}){}$\1\5
${}\|d[\|i-\T{1}]\K\T{1},\39\|i\MM;{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{for} ${}(\|j\K\|i-\T{1},\39\|k\K\\{nn}-\T{2};{}$ ${}\|d[\|j]>\T{0};{}$ ${}%
\|j\MM,\39\|k\MRL{-{\K}}\T{2}){}$\5
${}\{{}$\1\6
${}\|d[\|j]\K{-}\T{1},\39\|d[\|k]\K{+}\T{1};{}$\6
\&{if} ${}(\|j\E\T{0}){}$\1\5
\&{goto} \\{done};\2\6
\4${}\}{}$\2\6
${}\|d[\|j]\K{+}\T{1},\39\|i\K\\{nn}-\T{2};{}$\6
\4${}\}{}$\2\par
\U1.\fi

\M{4}\B\X4:Check the Strahler number\X${}\E{}$\6
\&{for} ${}(\|s\K\|j\K\|k\K\T{1};{}$ ${}\|k<\\{nn}-\T{1};{}$ ${}\|j\MRL{+{\K}}%
\|d[\|k],\39\|k\PP){}$\1\6
\&{if} ${}(\|j\G((\T{1}\LL\|s)-\T{1})){}$\1\5
${}\|s\PP;{}$\2\2\6
${}\|s\MM{}$;\C{ now \PB{\|s} is the Strahler number }\6
${}\\{count}[\|s]\PP,\39\\{serial}\PP;{}$\6
\&{if} ${}(\\{strahler}(\T{1})\I\|s){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"I\ goofed\ on\ case\ \%d}\)\.{.\\n"},\39%
\\{serial});{}$\6
\4${}\}{}$\2\par
\U1.\fi

\M{5}\B\X5:Subroutines\X${}\E{}$\6
\&{int} \\{strahler}(\&{int} \|x)\1\1\2\2\6
${}\{{}$\1\6
\&{register} \&{int} \\{sl}${},{}$ \\{sr};\7
\&{if} (\|l[\|x])\1\5
${}\\{sl}\K\\{strahler}(\|l[\|x]);{}$\2\6
\&{else}\1\5
${}\\{sl}\K\T{0};{}$\2\6
\&{if} (\|r[\|x])\1\5
${}\\{sr}\K\\{strahler}(\|r[\|x]);{}$\2\6
\&{else}\1\5
${}\\{sr}\K\T{0};{}$\2\6
\&{return} ${}(\\{sl}>\\{sr}\?\\{sl}:\\{sl}<\\{sr}\?\\{sr}:\\{sl}+\T{1});{}$\6
\4${}\}{}$\2\par
\U1.\fi

\N{1}{6}The main algorithm.
A large family of bijections between nested strings and binary
trees was described by Proskurowski in {\sl JACM\/ \bf27} (1980), page~1:
We build a binary tree by choosing, at each step, some node and some
yet-unset link field in that node; then we look at the next element
\PB{\|d[\|p]} of the nested string. The link is set to a new node if \PB{$\|d[%
\|p]>\T{0}$},
and to null if \PB{$\|d[\|p]<\T{0}$}. The bijection implemented here is of that
type.

To decide what link should be constructed next,
we use a heap-like data structure \PB{\|h[\T{1}]}, \PB{\|h[\T{2}]},
\dots, in which cell $k$ is the parent of cells $2k$ and $2k+1$.
The cell elements are pointers to nodes in the tree being built, and
the nodes recorded in the heap can be embedded as a subtree of that tree.
(In other words, if $h[k]$ and $h[\lfloor k/2\rfloor]$ are both
nonzero, they point to nodes of the tree in which the first is
a descendant of the second. It might be helpful to imagine a set
of pebbles on the tree, with the heap cells recording the positions
of those pebbles.)
When $h[2k]=0$, meaning that heap cell $2k$ is empty, we also have
$h[2k+1]=0$. The basic idea of the algorithm is to attempt to
fill the first empty cell $k$ in the heap, by setting the links
of the tree node pointed to by $h[k/2]$.

The number of elements in the heap is always the partial sum
$d[0]+\cdots+d[p]$. If this number is $2^t-1$ or more, the
Strahler number of the binary tree is at least~$t$. Conversely,
if the Strahler number is~$s$, one can show without difficulty
that the partial sum will indeed reach the value $2^s-1$ at some point,
with the heap at that time containing the ``topmost'' complete subtree
of size $2^s-1$ embedded in the tree.

For validity of this algorithm, we don't really need to choose the
first hole in the heap. Any rule for choosing~$k$ would work, provided only
that (a)~$k$ is even; (b)~$h[k/2]\ne0$; and
(c)~$k\ge 2^t$ implies $d[0]+\cdots+d[p]\ge 2^t-1$. Thus there are many
possible bijections, some of which are presumably easier
to analyze than others.

\fi

\M{7}Variable \PB{\|m} represents the number of nodes in the tree; variable %
\PB{\|p}
is our position in the nested string; and variable \PB{\|k} is a lower bound
on the location of the least hole in the heap.

\Y\B\4\X7:Find the tree corresponding to \PB{\|d}\X${}\E{}$\6
$\|h[\T{1}]\K\|m\K\T{1},\39\|k\K\T{2},\39\|p\K\T{0};{}$\6
\&{while} (\T{1})\5
${}\{{}$\1\6
\&{while} (\|h[\|k])\1\5
${}\|k\MRL{+{\K}}\T{2}{}$;\C{ find the smallest hole }\2\6
${}\\{kk}\K\|h[\|k\GG\T{1}]{}$;\C{ \PB{\\{kk}} is the node pointed to by \PB{%
\|k}'s parent }\6
\&{if} ${}(\|d[\PP\|p]>\T{0}){}$\1\5
${}\|h[\|k]\K\|l[\\{kk}]\K\PP\|m{}$;\5
\2\&{else}\1\5
${}\|l[\\{kk}]\K\T{0};{}$\2\6
\&{if} ${}(\|d[\PP\|p]>\T{0}){}$\1\5
${}\|h[\|k+\T{1}]\K\|r[\\{kk}]\K\PP\|m{}$;\5
\2\&{else}\1\5
${}\|r[\\{kk}]\K\T{0};{}$\2\6
\&{if} (\|h[\|k])\5
${}\{{}$\1\6
\&{if} ${}(\|h[\|k+\T{1}]){}$\1\5
\&{continue};\2\6
${}\\{kk}\K\|k;{}$\6
\4${}\}{}$\5
\2\&{else} \&{if} ${}(\|h[\|k+\T{1}]){}$\1\5
${}\\{kk}\K\|k+\T{1};{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\|h[\|k\GG\T{1}]\K\T{0},\39\\{kk}\K(\|k\GG\T{1})\XOR\T{1},\39\|k\K\\{kk}%
\AND{-}\T{2};{}$\6
\&{if} ${}(\|k\E\T{0}){}$\1\5
\&{break};\C{ we're done when the heap is empty }\2\6
\4${}\}{}$\2\6
\X8:Move the subheap rooted at \PB{\\{kk}} up one level\X;\6
\4${}\}{}$\2\par
\U1.\fi

\M{8}Let the binary representation of \PB{\\{kk}} be $(b_t\ldots b_0)_2$.
We want to set $h[(b_t\ldots b_1\alpha)_2]\gets h[(b_t\ldots b_0\alpha)_2]$
for all binary strings~$\alpha$.

\Y\B\4\X8:Move the subheap rooted at \PB{\\{kk}} up one level\X${}\E{}$\6
$\|j\K\T{0},\39\\{jj}\K\T{1},\39\|q[\T{0}]\K\\{kk},\39\\{qm}[\T{0}]\K\T{1};{}$\6
\&{while} ${}(\|j<\\{jj}){}$\5
${}\{{}$\1\6
${}\\{kk}\K\|q[\|j];{}$\6
${}\|h[((\\{kk}\GG\T{1})\AND{-}\\{qm}[\|j])+(\\{kk}\AND(\\{qm}[\|j]-\T{1}))]\K%
\|h[\\{kk}];{}$\6
\&{if} ${}(\|h[\\{kk}+\\{kk}]){}$\1\5
${}\|q[\\{jj}]\K\\{kk}+\\{kk},\39\|q[\\{jj}+\T{1}]\K\\{kk}+\\{kk}+\T{1},\39%
\\{qm}[\\{jj}]\K\\{qm}[\\{jj}+\T{1}]\K\\{qm}[\|j]\LL\T{1},\39\\{jj}\MRL{+{\K}}%
\T{2};{}$\2\6
\&{else}\1\5
${}\|h[\\{kk}]\K\T{0};{}$\2\6
${}\|j\PP;{}$\6
\4${}\}{}$\2\par
\Us7\ET9.\fi

\N{1}{9}The inverse algorithm. To reverse the process, we simply look at the
tree and build the nested string, instead of vice versa. The same
heap-oriented logic applies.

\Y\B\4\D$\\{check}(\|s)$ \6
${}\{{}$\5
\1\&{if} ${}(\|d[\PP\|p]\I\|s){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"Rejection\ at\ positi}\)\.{on\ \%d\ of\ case\ %
\%d!\\n"},\39\|p,\39\\{serial}){}$;\5
\2${}\}{}$\2\par
\Y\B\4\X9:Check the inverse bijection\X${}\E{}$\6
$\|h[\T{1}]\K\T{1},\39\|k\K\T{2},\39\|p\K\T{0};{}$\6
\&{while} (\T{1})\5
${}\{{}$\1\6
\&{while} (\|h[\|k])\1\5
${}\|k\MRL{+{\K}}\T{2}{}$;\C{ find the smallest hole }\2\6
${}\\{kk}\K\|h[\|k\GG\T{1}]{}$;\C{ \PB{\\{kk}} is the node pointed to by \PB{%
\|k}'s parent }\6
\&{if} (\|l[\\{kk}])\5
${}\{{}$\1\6
${}\|h[\|k]\K\|l[\\{kk}]{}$;\5
${}\\{check}({+}\T{1});{}$\6
\4${}\}{}$\5
\2\&{else}\1\5
${}\\{check}({-}\T{1});{}$\2\6
\&{if} (\|r[\\{kk}])\5
${}\{{}$\1\6
${}\|h[\|k+\T{1}]\K\|r[\\{kk}]{}$;\5
${}\\{check}({+}\T{1});{}$\6
\4${}\}{}$\5
\2\&{else}\1\5
${}\\{check}({-}\T{1});{}$\2\6
\&{if} (\|h[\|k])\5
${}\{{}$\1\6
\&{if} ${}(\|h[\|k+\T{1}]){}$\1\5
\&{continue};\2\6
${}\\{kk}\K\|k;{}$\6
\4${}\}{}$\5
\2\&{else} \&{if} ${}(\|h[\|k+\T{1}]){}$\1\5
${}\\{kk}\K\|k+\T{1};{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\|h[\|k\GG\T{1}]\K\T{0},\39\\{kk}\K(\|k\GG\T{1})\XOR\T{1},\39\|k\K\\{kk}%
\AND{-}\T{2};{}$\6
\&{if} ${}(\|k\E\T{0}){}$\1\5
\&{break};\C{ we're done when the heap is empty }\2\6
\4${}\}{}$\2\6
\X8:Move the subheap rooted at \PB{\\{kk}} up one level\X;\6
\4${}\}{}$\2\par
\U1.\fi

\N{1}{10}Index.

\fi


\inx
\fin
\con
